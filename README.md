# å®¢æˆ·è¿½è¸ªç³»ç»Ÿéœ€æ±‚æ–‡æ¡£

## ğŸ“‹ é¡¹ç›®æ¦‚è¿°

### é¡¹ç›®åç§°
å®¢æˆ·è¿½è¸ªç³»ç»Ÿ (Customer Tracking System)

### é¡¹ç›®èƒŒæ™¯
å¼€å‘ä¸€ä¸ªç®€å•é«˜æ•ˆçš„å®¢æˆ·è¿½è¸ªç³»ç»Ÿï¼Œå¸®åŠ©ç”¨æˆ·è®°å½•å’Œç®¡ç†å®¢æˆ·ä¿¡æ¯ï¼Œè·Ÿè¸ªå®¢æˆ·è·Ÿè¿›çŠ¶æ€ï¼Œæé«˜å®¢æˆ·æœåŠ¡è´¨é‡å’Œé”€å”®è½¬åŒ–ç‡ã€‚æ”¯æŒå¤šç”¨æˆ·ä½¿ç”¨ï¼Œæ¯ä¸ªç”¨æˆ·åªèƒ½ç®¡ç†è‡ªå·±åˆ›å»ºçš„å®¢æˆ·ä¿¡æ¯ã€‚

### é¡¹ç›®ç›®æ ‡
- æä¾›å®‰å…¨çš„ç”¨æˆ·è®¤è¯å’Œæƒé™æ§åˆ¶ç³»ç»Ÿ
- æä¾›ç®€æ´æ˜“ç”¨çš„å®¢æˆ·ä¿¡æ¯ç®¡ç†ç•Œé¢
- æ”¯æŒå®¢æˆ·è·Ÿè¿›è®°å½•çš„æ—¶é—´çº¿å±•ç¤º
- ä¼˜åŒ–ç§»åŠ¨ç«¯æµè§ˆå™¨ä½“éªŒ
- æä¾›å¿«é€Ÿçš„æ•°æ®æŸ¥è¯¢å’Œå±•ç¤º
- ç¡®ä¿æ•°æ®éš”ç¦»ï¼Œæ¯ä¸ªç”¨æˆ·åªèƒ½è®¿é—®è‡ªå·±çš„æ•°æ®

---

## ğŸ¯ åŠŸèƒ½éœ€æ±‚

### 1. ç”¨æˆ·è®¤è¯ç®¡ç†
- **ç”¨æˆ·ç™»å½•é¡µé¢**ï¼šæä¾›ç”¨æˆ·å/å¯†ç ç™»å½•ç•Œé¢
- **JWTè®¤è¯**ï¼šåŸºäºJWT Tokençš„èº«ä»½éªŒè¯
- **è‡ªåŠ¨ç™»å½•**ï¼šè®°ä½ç™»å½•çŠ¶æ€ï¼Œæ”¯æŒTokenè‡ªåŠ¨ç»­æœŸ
- **ç™»å‡ºåŠŸèƒ½**ï¼šå®‰å…¨é€€å‡ºå¹¶æ¸…é™¤è®¤è¯ä¿¡æ¯
- **è·¯ç”±ä¿æŠ¤**ï¼šæœªè®¤è¯ç”¨æˆ·è‡ªåŠ¨è·³è½¬åˆ°ç™»å½•é¡µ
- **å‘½ä»¤è¡Œç”¨æˆ·ç®¡ç†**ï¼šæ”¯æŒé€šè¿‡CLIæ·»åŠ ç”¨æˆ·

### 2. å®¢æˆ·ä¿¡æ¯ç®¡ç†
- **å®¢æˆ·åˆ—è¡¨å±•ç¤º**ï¼šåˆ†é¡µæ˜¾ç¤ºå½“å‰ç”¨æˆ·çš„å®¢æˆ·åŸºæœ¬ä¿¡æ¯
- **å®¢æˆ·ä¿¡æ¯å½•å…¥**ï¼šæ·»åŠ æ–°å®¢æˆ·ä¿¡æ¯ï¼ˆè‡ªåŠ¨å…³è”å½“å‰ç”¨æˆ·ï¼‰
- **å®¢æˆ·ä¿¡æ¯ç¼–è¾‘**ï¼šä¿®æ”¹å®¢æˆ·åŸºæœ¬ä¿¡æ¯ï¼ˆä»…é™è‡ªå·±åˆ›å»ºçš„å®¢æˆ·ï¼‰
- **å®¢æˆ·ä¿¡æ¯åˆ é™¤**ï¼šåˆ é™¤å®¢æˆ·è®°å½•ï¼ˆä»…é™è‡ªå·±åˆ›å»ºçš„å®¢æˆ·ï¼Œè½¯åˆ é™¤ï¼‰
- **æ•°æ®éš”ç¦»**ï¼šç”¨æˆ·åªèƒ½æŸ¥çœ‹å’Œæ“ä½œè‡ªå·±åˆ›å»ºçš„å®¢æˆ·

### 3. å®¢æˆ·è¿½è¸ªç®¡ç†  
- **è¿½è¸ªè®°å½•æ·»åŠ **ï¼šä¸ºè‡ªå·±çš„å®¢æˆ·æ·»åŠ è·Ÿè¿›è®°å½•
- **è¿½è¸ªè®°å½•æŸ¥çœ‹**ï¼šæ—¶é—´çº¿æ–¹å¼å±•ç¤ºè·Ÿè¿›å†å²
- **è¿½è¸ªè®°å½•ç¼–è¾‘**ï¼šä¿®æ”¹è·Ÿè¿›è®°å½•å†…å®¹
- **ä¸‹æ¬¡è·Ÿè¿›åŠ¨ä½œ**ï¼šé€‰æ‹©ç»§ç»­è·Ÿè¿›æˆ–ç»“æŸè·Ÿè¿›
- **æƒé™æ§åˆ¶**ï¼šåªèƒ½æ“ä½œè‡ªå·±å®¢æˆ·çš„è·Ÿè¿›è®°å½•

---

## ğŸ’» æŠ€æœ¯æ¶æ„

### åç«¯æŠ€æœ¯æ ˆ
```yaml
è¯­è¨€: Rust Edition 2021/2024
Webæ¡†æ¶: Axum 0.8.x
æ•°æ®åº“: SQLite (æœ€æ–°ç‰ˆæœ¬)
ORM: Sea-ORM (æœ€æ–°ç‰ˆæœ¬) 
å‘½ä»¤è¡Œ: Clap 4.x
è®¤è¯: JWT Token (jsonwebtoken)
å¯†ç åŠ å¯†: bcrypt
ä¸­é—´ä»¶: axum-extra (JWT middleware)
æ—¥å¿—: tracing
é…ç½®: config/dotenv
```

### å‰ç«¯æŠ€æœ¯æ ˆ
```yaml
æ¡†æ¶: Vue 3.x (Composition API)
UIç»„ä»¶åº“: Naive UI
çŠ¶æ€ç®¡ç†: Pinia
è·¯ç”±: Vue Router 4.x (è·¯ç”±å®ˆå«)
HTTPå®¢æˆ·ç«¯: Axios (è¯·æ±‚/å“åº”æ‹¦æˆªå™¨)
æ„å»ºå·¥å…·: Vite
ç±»å‹æ£€æŸ¥: TypeScript
æœ¬åœ°å­˜å‚¨: localStorage (Tokenå­˜å‚¨)
```

### éƒ¨ç½²ç¯å¢ƒ
```yaml
ç›®æ ‡è®¾å¤‡: ç§»åŠ¨ç«¯æµè§ˆå™¨ä¼˜å…ˆ
å…¼å®¹æ€§: ç°ä»£æµè§ˆå™¨ (Chrome, Safari, Firefox)
å“åº”å¼: ç§»åŠ¨ç«¯ä¼˜å…ˆè®¾è®¡
```

---

## ğŸ—ƒï¸ æ•°æ®æ¨¡å‹è®¾è®¡

### 1. ç”¨æˆ·è¡¨ (users)
```sql
CREATE TABLE users (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    username VARCHAR(50) UNIQUE NOT NULL,
    password_hash VARCHAR(255) NOT NULL,
    name VARCHAR(100) NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    is_active BOOLEAN DEFAULT TRUE,
    last_login_at TIMESTAMP NULL
);

CREATE INDEX idx_users_username ON users(username);
CREATE INDEX idx_users_is_active ON users(is_active);
```

### 2. å®¢æˆ·è¡¨ (customers)
```sql
CREATE TABLE customers (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    name VARCHAR(100) NOT NULL,
    phone VARCHAR(20),
    address TEXT,
    notes TEXT,
    rate INTEGER DEFAULT 0 CHECK(rate >= 0 AND rate <= 5),
    user_id INTEGER NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    is_deleted BOOLEAN DEFAULT FALSE,
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
);

CREATE INDEX idx_customers_user_id ON customers(user_id);
CREATE INDEX idx_customers_is_deleted ON customers(is_deleted);
CREATE INDEX idx_customers_name ON customers(name);
```

### 3. å®¢æˆ·è¿½è¸ªè®°å½•è¡¨ (customer_tracks)
```sql
CREATE TABLE customer_tracks (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    customer_id INTEGER NOT NULL,
    content TEXT NOT NULL,
    next_action VARCHAR(64) DEFAULT 'ç»§ç»­è·Ÿè¿›' CHECK(next_action IN ('ç»§ç»­è·Ÿè¿›', 'ç»“æŸè·Ÿè¿›')),
    track_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    next_track_time TIMESTAMP,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (customer_id) REFERENCES customers(id) ON DELETE CASCADE
);

CREATE INDEX idx_customer_tracks_customer_id ON customer_tracks(customer_id);
CREATE INDEX idx_customer_tracks_track_time ON customer_tracks(track_time);
```

### 4. Sea-ORM å®ä½“å®šä¹‰

#### User Entity
```rust
use sea_orm::entity::prelude::*;
use serde::{Deserialize, Serialize};

#[derive(Clone, Debug, PartialEq, DeriveEntityModel, Serialize, Deserialize)]
#[sea_orm(table_name = "users")]
pub struct Model {
    #[sea_orm(primary_key)]
    pub id: i32,
    #[sea_orm(unique)]
    pub username: String,
    #[serde(skip_serializing)]
    pub password_hash: String,
    pub name: String,
    pub created_at: ChronoDateTimeUtc,
    pub updated_at: ChronoDateTimeUtc,
    pub is_active: bool,
    pub last_login_at: Option<ChronoDateTimeUtc>,
}

#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
pub enum Relation {
    #[sea_orm(has_many = "super::customer::Entity")]
    Customer,
}

impl Related<super::customer::Entity> for Entity {
    fn to() -> RelationDef {
        Relation::Customer.def()
    }
}

impl ActiveModelBehavior for ActiveModel {}
```

#### Customer Entity
```rust
use sea_orm::entity::prelude::*;
use serde::{Deserialize, Serialize};

#[derive(Clone, Debug, PartialEq, DeriveEntityModel, Serialize, Deserialize)]
#[sea_orm(table_name = "customers")]
pub struct Model {
    #[sea_orm(primary_key)]
    pub id: i32,
    pub name: String,
    pub phone: Option<String>,
    pub address: Option<String>,
    pub notes: Option<String>,
    pub rate: i32,
    pub user_id: i32,
    pub created_at: ChronoDateTimeUtc,
    pub updated_at: ChronoDateTimeUtc,
    pub is_deleted: bool,
}

#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
pub enum Relation {
    #[sea_orm(belongs_to = "super::user::Entity", from = "Column::UserId", to = "super::user::Column::Id")]
    User,
    #[sea_orm(has_many = "super::customer_track::Entity")]
    CustomerTrack,
}

impl Related<super::user::Entity> for Entity {
    fn to() -> RelationDef {
        Relation::User.def()
    }
}

impl Related<super::customer_track::Entity> for Entity {
    fn to() -> RelationDef {
        Relation::CustomerTrack.def()
    }
}

impl ActiveModelBehavior for ActiveModel {}
```

#### NextAction Enum
```rust
use sea_orm::entity::prelude::*;
use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, PartialEq, Eq, EnumIter, DeriveActiveEnum, Serialize, Deserialize)]
#[sea_orm(rs_type = "String", db_type = "String(Some(64))")]
pub enum NextAction {
    #[sea_orm(string_value = "ç»§ç»­è·Ÿè¿›")]
    Continue,
    #[sea_orm(string_value = "ç»“æŸè·Ÿè¿›")]
    End,
}

impl Default for NextAction {
    fn default() -> Self {
        NextAction::Continue
    }
}

impl NextAction {
    pub fn as_str(&self) -> &str {
        match self {
            NextAction::Continue => "ç»§ç»­è·Ÿè¿›",
            NextAction::End => "ç»“æŸè·Ÿè¿›",
        }
    }
    
    pub fn from_str(s: &str) -> Option<Self> {
        match s {
            "ç»§ç»­è·Ÿè¿›" => Some(NextAction::Continue),
            "ç»“æŸè·Ÿè¿›" => Some(NextAction::End),
            _ => None,
        }
    }
    
    pub fn variants() -> Vec<&'static str> {
        vec!["ç»§ç»­è·Ÿè¿›", "ç»“æŸè·Ÿè¿›"]
    }
}
```

#### CustomerTrack Entity
```rust
use sea_orm::entity::prelude::*;
use serde::{Deserialize, Serialize};
use super::next_action::NextAction;

#[derive(Clone, Debug, PartialEq, DeriveEntityModel, Serialize, Deserialize)]
#[sea_orm(table_name = "customer_tracks")]
pub struct Model {
    #[sea_orm(primary_key)]
    pub id: i32,
    pub customer_id: i32,
    pub content: String,
    pub next_action: NextAction,
    pub track_time: ChronoDateTimeUtc,
    pub next_track_time: Option<ChronoDateTimeUtc>,
    pub created_at: ChronoDateTimeUtc,
    pub updated_at: ChronoDateTimeUtc,
}

#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
pub enum Relation {
    #[sea_orm(belongs_to = "super::customer::Entity", from = "Column::CustomerId", to = "super::customer::Column::Id")]
    Customer,
}

impl Related<super::customer::Entity> for Entity {
    fn to() -> RelationDef {
        Relation::Customer.def()
    }
}

impl ActiveModelBehavior for ActiveModel {}
```

---

## ğŸ”Œ APIæ¥å£è®¾è®¡

### 1. JWTè®¤è¯ä¸­é—´ä»¶
```rust
use axum::{
    extract::{Request, State},
    http::{header::AUTHORIZATION, StatusCode},
    middleware::Next,
    response::Response,
    Extension,
};
use jsonwebtoken::{decode, DecodingKey, Validation};
use serde::{Deserialize, Serialize};

#[derive(Debug, Serialize, Deserialize)]
pub struct Claims {
    pub user_id: i32,
    pub username: String,
    pub name: String,
    pub exp: usize,
    pub iat: usize,
}

#[derive(Debug, Clone)]
pub struct CurrentUser {
    pub id: i32,
    pub username: String,
    pub name: String,
}

pub async fn auth_middleware(
    State(app_state): State<AppState>,
    mut request: Request,
    next: Next,
) -> Result<Response, StatusCode> {
    let auth_header = request
        .headers()
        .get(AUTHORIZATION)
        .and_then(|header| header.to_str().ok())
        .and_then(|header| header.strip_prefix("Bearer "));

    let token = match auth_header {
        Some(token) => token,
        None => return Err(StatusCode::UNAUTHORIZED),
    };

    let claims = decode::<Claims>(
        token,
        &DecodingKey::from_secret(app_state.jwt_secret.as_ref()),
        &Validation::default(),
    )
    .map_err(|_| StatusCode::UNAUTHORIZED)?;

    let current_user = CurrentUser {
        id: claims.claims.user_id,
        username: claims.claims.username,
        name: claims.claims.name,
    };

    request.extensions_mut().insert(current_user);
    Ok(next.run(request).await)
}
```

### 2. è®¤è¯ç›¸å…³API
```rust
// POST /api/auth/login
#[derive(Debug, Deserialize)]
pub struct LoginRequest {
    pub username: String,
    pub password: String,
}

#[derive(Debug, Serialize)]
pub struct LoginResponse {
    pub token: String,
    pub expires_in: i64,
    pub user: UserInfo,
}

#[derive(Debug, Serialize)]
pub struct UserInfo {
    pub id: i32,
    pub username: String,
    pub name: String,
    pub last_login_at: Option<ChronoDateTimeUtc>,
}

// POST /api/auth/refresh - åˆ·æ–°Token
#[derive(Debug, Serialize)]
pub struct RefreshTokenResponse {
    pub token: String,
    pub expires_in: i64,
}

// POST /api/auth/logout
#[derive(Debug, Serialize)]
pub struct LogoutResponse {
    pub message: String,
}

// GET /api/auth/me - è·å–å½“å‰ç”¨æˆ·ä¿¡æ¯
pub async fn get_current_user(
    Extension(current_user): Extension<CurrentUser>,
) -> Result<Json<UserInfo>, StatusCode> {
    Ok(Json(UserInfo {
        id: current_user.id,
        username: current_user.username,
        name: current_user.name,
        last_login_at: None, // ä»æ•°æ®åº“è·å–
    }))
}
```

### 3. å®¢æˆ·ç®¡ç†APIï¼ˆå¸¦æƒé™æ§åˆ¶ï¼‰
```rust
use crate::entities::next_action::NextAction;
use axum::Extension;

// GET /api/customers?page=1&limit=20&search=
#[derive(Debug, Serialize)]
pub struct CustomerListResponse {
    pub customers: Vec<CustomerWithLatestTrack>,
    pub total: u64,
    pub page: u32,
    pub limit: u32,
}

#[derive(Debug, Serialize)]
pub struct CustomerWithLatestTrack {
    pub id: i32,
    pub name: String,
    pub phone: Option<String>,
    pub rate: i32,
    pub notes: Option<String>,
    pub latest_track_time: Option<ChronoDateTimeUtc>,
    pub latest_next_action: Option<NextAction>,
    pub latest_content: Option<String>,
    pub created_at: ChronoDateTimeUtc,
}

// å®¢æˆ·åˆ—è¡¨å¤„ç†å™¨ï¼ˆåªè¿”å›å½“å‰ç”¨æˆ·çš„å®¢æˆ·ï¼‰
pub async fn list_customers(
    Extension(current_user): Extension<CurrentUser>,
    Query(params): Query<CustomerListQuery>,
    State(app_state): State<AppState>,
) -> Result<Json<CustomerListResponse>, StatusCode> {
    let customers = Customer::find()
        .filter(customer::Column::UserId.eq(current_user.id))
        .filter(customer::Column::IsDeleted.eq(false))
        // æ·»åŠ æœç´¢è¿‡æ»¤
        .apply_if(params.search, |query, search| {
            query.filter(
                customer::Column::Name.contains(&search)
                    .or(customer::Column::Phone.contains(&search))
            )
        })
        .order_by_desc(customer::Column::UpdatedAt)
        .paginate(&app_state.db, params.limit as u64);

    // è·å–åˆ†é¡µæ•°æ®å’Œæ€»æ•°
    let customers_page = customers.fetch_page(params.page as u64 - 1).await
        .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;
    
    let total = customers.num_items().await
        .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;

    // ... å¤„ç†æœ€æ–°è·Ÿè¿›è®°å½•å…³è”æŸ¥è¯¢
    
    Ok(Json(CustomerListResponse {
        customers: customer_with_tracks,
        total,
        page: params.page,
        limit: params.limit,
    }))
}

// POST /api/customers - åˆ›å»ºå®¢æˆ·ï¼ˆè‡ªåŠ¨å…³è”å½“å‰ç”¨æˆ·ï¼‰
#[derive(Debug, Deserialize)]
pub struct CreateCustomerRequest {
    pub name: String,
    pub phone: Option<String>,
    pub address: Option<String>,
    pub notes: Option<String>,
    pub rate: Option<i32>,
}

pub async fn create_customer(
    Extension(current_user): Extension<CurrentUser>,
    State(app_state): State<AppState>,
    Json(req): Json<CreateCustomerRequest>,
) -> Result<Json<Customer>, StatusCode> {
    let customer = customer::ActiveModel {
        name: Set(req.name),
        phone: Set(req.phone),
        address: Set(req.address),
        notes: Set(req.notes),
        rate: Set(req.rate.unwrap_or(0)),
        user_id: Set(current_user.id), // è‡ªåŠ¨å…³è”å½“å‰ç”¨æˆ·
        created_at: Set(Utc::now()),
        updated_at: Set(Utc::now()),
        ..Default::default()
    };

    let customer = customer.insert(&app_state.db).await
        .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;

    Ok(Json(customer))
}

// PUT /api/customers/:id - æ›´æ–°å®¢æˆ·ï¼ˆåªèƒ½æ›´æ–°è‡ªå·±çš„å®¢æˆ·ï¼‰
pub async fn update_customer(
    Extension(current_user): Extension<CurrentUser>,
    Path(customer_id): Path<i32>,
    State(app_state): State<AppState>,
    Json(req): Json<UpdateCustomerRequest>,
) -> Result<Json<Customer>, StatusCode> {
    // æ£€æŸ¥å®¢æˆ·æ˜¯å¦å±äºå½“å‰ç”¨æˆ·
    let customer = Customer::find_by_id(customer_id)
        .filter(customer::Column::UserId.eq(current_user.id))
        .filter(customer::Column::IsDeleted.eq(false))
        .one(&app_state.db)
        .await
        .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?
        .ok_or(StatusCode::NOT_FOUND)?;

    // æ‰§è¡Œæ›´æ–°æ“ä½œ
    let mut customer: customer::ActiveModel = customer.into();
    
    if let Some(name) = req.name {
        customer.name = Set(name);
    }
    // ... å…¶ä»–å­—æ®µæ›´æ–°
    customer.updated_at = Set(Utc::now());

    let updated_customer = customer.update(&app_state.db).await
        .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;

    Ok(Json(updated_customer))
}
```

### 4. å®¢æˆ·è¿½è¸ªAPIï¼ˆå¸¦æƒé™æ§åˆ¶ï¼‰
```rust
// GET /api/customers/:id/tracks - è·å–å®¢æˆ·è·Ÿè¿›è®°å½•
pub async fn list_customer_tracks(
    Extension(current_user): Extension<CurrentUser>,
    Path(customer_id): Path<i32>,
    State(app_state): State<AppState>,
) -> Result<Json<CustomerTrackListResponse>, StatusCode> {
    // é¦–å…ˆéªŒè¯å®¢æˆ·æ˜¯å¦å±äºå½“å‰ç”¨æˆ·
    let customer = Customer::find_by_id(customer_id)
        .filter(customer::Column::UserId.eq(current_user.id))
        .filter(customer::Column::IsDeleted.eq(false))
        .one(&app_state.db)
        .await
        .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?
        .ok_or(StatusCode::NOT_FOUND)?;

    // è·å–è·Ÿè¿›è®°å½•
    let tracks = CustomerTrack::find()
        .filter(customer_track::Column::CustomerId.eq(customer_id))
        .order_by_desc(customer_track::Column::TrackTime)
        .all(&app_state.db)
        .await
        .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;

    Ok(Json(CustomerTrackListResponse {
        tracks: tracks.into_iter().map(|t| CustomerTrackInfo::from(t)).collect(),
        customer: CustomerInfo::from(customer),
    }))
}

// POST /api/customers/:id/tracks - åˆ›å»ºè·Ÿè¿›è®°å½•
pub async fn create_customer_track(
    Extension(current_user): Extension<CurrentUser>,
    Path(customer_id): Path<i32>,
    State(app_state): State<AppState>,
    Json(req): Json<CreateTrackRequest>,
) -> Result<Json<CustomerTrackInfo>, StatusCode> {
    // éªŒè¯å®¢æˆ·æ˜¯å¦å±äºå½“å‰ç”¨æˆ·
    let _customer = Customer::find_by_id(customer_id)
        .filter(customer::Column::UserId.eq(current_user.id))
        .filter(customer::Column::IsDeleted.eq(false))
        .one(&app_state.db)
        .await
        .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?
        .ok_or(StatusCode::NOT_FOUND)?;

    let track = customer_track::ActiveModel {
        customer_id: Set(customer_id),
        content: Set(req.content),
        next_action: Set(req.next_action.unwrap_or(NextAction::Continue)),
        track_time: Set(req.track_time.unwrap_or_else(|| Utc::now())),
        next_track_time: Set(req.next_track_time),
        created_at: Set(Utc::now()),
        updated_at: Set(Utc::now()),
        ..Default::default()
    };

    let track = track.insert(&app_state.db).await
        .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;

    Ok(Json(CustomerTrackInfo::from(track)))
}
```

### 5. Axumè·¯ç”±å®šä¹‰
```rust
use axum::{
    routing::{get, post, put, delete},
    Router, middleware,
};
use tower_http::cors::CorsLayer;

pub fn create_routes(app_state: AppState) -> Router {
    Router::new()
        // å…¬å¼€è·¯ç”±ï¼ˆæ— éœ€è®¤è¯ï¼‰
        .route("/api/auth/login", post(auth::login))
        .route("/api/health", get(|| async { "OK" }))
        
        // å—ä¿æŠ¤è·¯ç”±ï¼ˆéœ€è¦è®¤è¯ï¼‰
        .route("/api/auth/me", get(auth::get_current_user))
        .route("/api/auth/logout", post(auth::logout))
        .route("/api/auth/refresh", post(auth::refresh_token))
        
        // å®¢æˆ·è·¯ç”±
        .route("/api/customers", get(customer::list).post(customer::create))
        .route("/api/customers/:id", 
            get(customer::get)
            .put(customer::update)
            .delete(customer::delete)
        )
        
        // å®¢æˆ·è¿½è¸ªè·¯ç”±
        .route("/api/customers/:id/tracks", 
            get(customer_track::list)
            .post(customer_track::create)
        )
        .route("/api/tracks/:id", 
            put(customer_track::update)
            .delete(customer_track::delete)
        )
        .route("/api/tracks/actions", get(customer_track::get_next_actions))
        
        // å¯¹å—ä¿æŠ¤è·¯ç”±åº”ç”¨è®¤è¯ä¸­é—´ä»¶
        .layer(middleware::from_fn_with_state(app_state.clone(), auth_middleware))
        
        // CORSä¸­é—´ä»¶
        .layer(CorsLayer::permissive())
        
        // é™æ€æ–‡ä»¶æœåŠ¡
        .fallback_service(ServeDir::new("dist"))
        
        .with_state(app_state)
}

// éœ€è¦å°†å…¬å¼€è·¯ç”±ä»è®¤è¯ä¸­é—´ä»¶ä¸­æ’é™¤
pub fn create_routes_with_auth(app_state: AppState) -> Router {
    let public_routes = Router::new()
        .route("/api/auth/login", post(auth::login))
        .route("/api/health", get(|| async { "OK" }))
        .with_state(app_state.clone());

    let protected_routes = Router::new()
        .route("/api/auth/me", get(auth::get_current_user))
        .route("/api/auth/logout", post(auth::logout))
        .route("/api/auth/refresh", post(auth::refresh_token))
        .route("/api/customers", get(customer::list).post(customer::create))
        .route("/api/customers/:id", 
            get(customer::get).put(customer::update).delete(customer::delete))
        .route("/api/customers/:id/tracks", 
            get(customer_track::list).post(customer_track::create))
        .route("/api/tracks/:id", 
            put(customer_track::update).delete(customer_track::delete))
        .route("/api/tracks/actions", get(customer_track::get_next_actions))
        .layer(middleware::from_fn_with_state(
            app_state.clone(), 
            auth_middleware
        ))
        .with_state(app_state.clone());

    Router::new()
        .merge(public_routes)
        .merge(protected_routes)
        .layer(CorsLayer::permissive())
        .fallback_service(ServeDir::new("dist"))
}
```

---

## ğŸ¨ å‰ç«¯ç•Œé¢è®¾è®¡

### 1. TypeScript ç±»å‹å®šä¹‰
```typescript
// types/auth.ts
export interface User {
  id: number
  username: string
  name: string
  last_login_at?: string
}

export interface LoginRequest {
  username: string
  password: string
}

export interface LoginResponse {
  token: string
  expires_in: number
  user: User
}

export interface AuthState {
  token: string | null
  user: User | null
  isAuthenticated: boolean
}

// types/customer.ts
export interface Customer {
  id: number
  name: string
  phone?: string
  address?: string
  notes?: string
  rate: number
  user_id: number
  created_at: string
  updated_at: string
}

export interface CustomerWithLatestTrack extends Customer {
  latest_track_time?: string
  latest_next_action?: NextAction
  latest_content?: string
}
```

### 2. è®¤è¯çŠ¶æ€ç®¡ç† (Pinia Store)
```typescript
// stores/auth.ts
import { defineStore } from 'pinia'
import { ref, computed } from 'vue'
import { authApi } from '@/services/auth'
import type { User, AuthState, LoginRequest } from '@/types/auth'

export const useAuthStore = defineStore('auth', () => {
  const token = ref<string | null>(localStorage.getItem('token'))
  const user = ref<User | null>(null)

  const isAuthenticated = computed(() => !!token.value && !!user.value)

  // åˆå§‹åŒ–è®¤è¯çŠ¶æ€
  const initAuth = async () => {
    const savedToken = localStorage.getItem('token')
    if (savedToken) {
      token.value = savedToken
      try {
        const response = await authApi.getCurrentUser()
        user.value = response.data
        return true
      } catch (error) {
        // Tokenæ— æ•ˆï¼Œæ¸…é™¤æœ¬åœ°å­˜å‚¨
        logout()
        return false
      }
    }
    return false
  }

  // ç™»å½•
  const login = async (credentials: LoginRequest) => {
    try {
      const response = await authApi.login(credentials)
      token.value = response.data.token
      user.value = response.data.user
      
      // ä¿å­˜åˆ°æœ¬åœ°å­˜å‚¨
      localStorage.setItem('token', response.data.token)
      
      return { success: true, user: response.data.user }
    } catch (error: any) {
      return { 
        success: false, 
        message: error.response?.data?.message || 'ç™»å½•å¤±è´¥' 
      }
    }
  }

  // ç™»å‡º
  const logout = async () => {
    try {
      if (token.value) {
        await authApi.logout()
      }
    } catch (error) {
      // å¿½ç•¥ç™»å‡ºAPIé”™è¯¯
    } finally {
      token.value = null
      user.value = null
      localStorage.removeItem('token')
    }
  }

  // åˆ·æ–°Token
  const refreshToken = async () => {
    try {
      const response = await authApi.refreshToken()
      token.value = response.data.token
      localStorage.setItem('token', response.data.token)
      return true
    } catch (error) {
      logout()
      return false
    }
  }

  return {
    token,
    user,
    isAuthenticated,
    initAuth,
    login,
    logout,
    refreshToken
  }
})
```

### 3. ç™»å½•é¡µé¢
```vue
<!-- views/Login.vue -->
<template>
  <div class="login-container">
    <div class="login-card">
      <n-card title="å®¢æˆ·è¿½è¸ªç³»ç»Ÿ" size="large">
        <template #header-extra>
          <n-icon :component="PersonCircleOutline" size="24" />
        </template>
        
        <n-form
          ref="loginFormRef"
          :model="loginForm"
          :rules="loginFormRules"
          size="large"
          :show-require-mark="false"
        >
          <n-form-item path="username">
            <n-input
              v-model:value="loginForm.username"
              placeholder="è¯·è¾“å…¥ç”¨æˆ·å"
              clearable
              @keydown.enter="handleLogin"
            >
              <template #prefix>
                <n-icon :component="PersonOutline" />
              </template>
            </n-input>
          </n-form-item>
          
          <n-form-item path="password">
            <n-input
              v-model:value="loginForm.password"
              type="password"
              placeholder="è¯·è¾“å…¥å¯†ç "
              show-password-on="click"
              @keydown.enter="handleLogin"
            >
              <template #prefix>
                <n-icon :component="LockClosedOutline" />
              </template>
            </n-input>
          </n-form-item>
          
          <n-form-item>
            <n-checkbox v-model:checked="rememberMe">
              è®°ä½ç™»å½•çŠ¶æ€
            </n-checkbox>
          </n-form-item>
        </n-form>
        
        <template #action>
          <n-space vertical size="large" style="width: 100%">
            <n-button
              type="primary"
              size="large"
              block
              :loading="loginLoading"
              @click="handleLogin"
            >
              ç™»å½•
            </n-button>
            
            <n-text depth="3" style="text-align: center; display: block">
              å®¢æˆ·è¿½è¸ªç®¡ç†ç³»ç»Ÿ v1.0
            </n-text>
          </n-space>
        </template>
      </n-card>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, reactive, onMounted } from 'vue'
import { useRouter, useRoute } from 'vue-router'
import { useMessage, type FormInst, type FormRules } from 'naive-ui'
import { PersonCircleOutline, PersonOutline, LockClosedOutline } from '@vicons/ionicons5'
import { useAuthStore } from '@/stores/auth'
import type { LoginRequest } from '@/types/auth'

const router = useRouter()
const route = useRoute()
const message = useMessage()
const authStore = useAuthStore()

const loginFormRef = ref<FormInst | null>(null)
const loginLoading = ref(false)
const rememberMe = ref(true)

const loginForm = reactive<LoginRequest>({
  username: '',
  password: ''
})

const loginFormRules: FormRules = {
  username: [
    { required: true, message: 'è¯·è¾“å…¥ç”¨æˆ·å', trigger: ['input', 'blur'] },
    { min: 3, max: 50, message: 'ç”¨æˆ·åé•¿åº¦ä¸º 3-50 ä¸ªå­—ç¬¦', trigger: ['input', 'blur'] }
  ],
  password: [
    { required: true, message: 'è¯·è¾“å…¥å¯†ç ', trigger: ['input', 'blur'] },
    { min: 6, message: 'å¯†ç é•¿åº¦ä¸èƒ½å°‘äº 6 ä¸ªå­—ç¬¦', trigger: ['input', 'blur'] }
  ]
}

const handleLogin = async () => {
  if (!loginFormRef.value) return
  
  try {
    await loginFormRef.value.validate()
    loginLoading.value = true
    
    const result = await authStore.login(loginForm)
    
    if (result.success) {
      message.success(`æ¬¢è¿å›æ¥ï¼Œ${result.user?.name}ï¼`)
      
      // è·³è½¬åˆ°ç›®æ ‡é¡µé¢æˆ–é¦–é¡µ
      const redirect = route.query.redirect as string || '/customers'
      router.push(redirect)
    } else {
      message.error(result.message || 'ç™»å½•å¤±è´¥')
    }
  } catch (error) {
    // è¡¨å•éªŒè¯å¤±è´¥
  } finally {
    loginLoading.value = false
  }
}

// é¡µé¢åŠ è½½æ—¶æ£€æŸ¥æ˜¯å¦å·²ç™»å½•
onMounted(() => {
  if (authStore.isAuthenticated) {
    router.push('/customers')
  }
})
</script>

<style scoped>
.login-container {
  min-height: 100vh;
  display: flex;
  align-items: center;
  justify-content: center;
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  padding: 20px;
}

.login-card {
  width: 100%;
  max-width: 400px;
  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
  border-radius: 16px;
  overflow: hidden;
  backdrop-filter: blur(8px);
}

.login-card :deep(.n-card) {
  background: rgba(255, 255, 255, 0.95);
}

.login-card :deep(.n-card-header) {
  text-align: center;
  font-weight: 600;
  font-size: 20px;
  color: #333;
}

@media (max-width: 480px) {
  .login-container {
    padding: 16px;
  }
  
  .login-card {
    max-width: none;
  }
}
</style>
```

### 4. è·¯ç”±å®ˆå«
```typescript
// router/index.ts
import { createRouter, createWebHistory } from 'vue-router'
import { useAuthStore } from '@/stores/auth'
import Login from '@/views/Login.vue'
import CustomerList from '@/views/CustomerList.vue'
import CustomerDetail from '@/views/CustomerDetail.vue'

const routes = [
  {
    path: '/login',
    name: 'Login',
    component: Login,
    meta: { requiresAuth: false }
  },
  {
    path: '/',
    redirect: '/customers'
  },
  {
    path: '/customers',
    name: 'CustomerList',
    component: CustomerList,
    meta: { requiresAuth: true }
  },
  {
    path: '/customers/:id',
    name: 'CustomerDetail',
    component: CustomerDetail,
    meta: { requiresAuth: true }
  }
]

const router = createRouter({
  history: createWebHistory(),
  routes
})

// è·¯ç”±å®ˆå«
router.beforeEach(async (to, from, next) => {
  const authStore = useAuthStore()
  
  // å¦‚æœè·¯ç”±éœ€è¦è®¤è¯
  if (to.meta.requiresAuth) {
    // æ£€æŸ¥æ˜¯å¦å·²è®¤è¯
    if (!authStore.isAuthenticated) {
      // å°è¯•ä»æœ¬åœ°å­˜å‚¨æ¢å¤è®¤è¯çŠ¶æ€
      const restored = await authStore.initAuth()
      
      if (!restored) {
        // è·³è½¬åˆ°ç™»å½•é¡µï¼Œå¹¶ä¿å­˜ç›®æ ‡è·¯ç”±
        next({
          path: '/login',
          query: { redirect: to.fullPath }
        })
        return
      }
    }
  }
  
  // å¦‚æœå·²ç™»å½•ç”¨æˆ·è®¿é—®ç™»å½•é¡µï¼Œè·³è½¬åˆ°å®¢æˆ·åˆ—è¡¨
  if (to.path === '/login' && authStore.isAuthenticated) {
    next('/customers')
    return
  }
  
  next()
})

export default router
```

### 5. HTTPè¯·æ±‚æ‹¦æˆªå™¨
```typescript
// utils/request.ts
import axios, { type AxiosResponse, type AxiosError } from 'axios'
import { useAuthStore } from '@/stores/auth'
import { useMessage } from 'naive-ui'
import router from '@/router'

const request = axios.create({
  baseURL: import.meta.env.VITE_API_BASE_URL || 'http://localhost:3000',
  timeout: 10000
})

// è¯·æ±‚æ‹¦æˆªå™¨ - æ·»åŠ è®¤è¯å¤´
request.interceptors.request.use(
  (config) => {
    const authStore = useAuthStore()
    
    if (authStore.token) {
      config.headers.Authorization = `Bearer ${authStore.token}`
    }
    
    return config
  },
  (error) => {
    return Promise.reject(error)
  }
)

// å“åº”æ‹¦æˆªå™¨ - å¤„ç†è®¤è¯é”™è¯¯
request.interceptors.response.use(
  (response: AxiosResponse) => {
    return response
  },
  async (error: AxiosError) => {
    const authStore = useAuthStore()
    const message = useMessage()
    
    if (error.response) {
      const status = error.response.status
      
      switch (status) {
        case 401:
          // Tokenè¿‡æœŸæˆ–æ— æ•ˆ
          message.error('ç™»å½•å·²è¿‡æœŸï¼Œè¯·é‡æ–°ç™»å½•')
          await authStore.logout()
          router.push('/login')
          break
          
        case 403:
          message.error('æ²¡æœ‰æƒé™æ‰§è¡Œæ­¤æ“ä½œ')
          break
          
        case 404:
          message.error('è¯·æ±‚çš„èµ„æºä¸å­˜åœ¨')
          break
          
        case 500:
          message.error('æœåŠ¡å™¨å†…éƒ¨é”™è¯¯')
          break
          
        default:
          message.error(error.response.data?.message || 'è¯·æ±‚å¤±è´¥')
      }
    } else if (error.request) {
      message.error('ç½‘ç»œè¿æ¥é”™è¯¯')
    } else {
      message.error('è¯·æ±‚é…ç½®é”™è¯¯')
    }
    
    return Promise.reject(error)
  }
)

export default request
```

### 6. æ›´æ–°åçš„å®¢æˆ·åˆ—è¡¨é¡µé¢
```vue
<!-- views/CustomerList.vue -->
<template>
  <div class="customer-list-container">
    <!-- é¡µé¢å¤´éƒ¨ -->
    <n-page-header @back="null">
      <template #title>
        å®¢æˆ·ç®¡ç†
      </template>
      <template #extra>
        <n-space>
          <n-text depth="3">
            æ¬¢è¿ï¼Œ{{ authStore.user?.name }}
          </n-text>
          <n-dropdown :options="userMenuOptions" @select="handleUserMenuSelect">
            <n-button quaternary circle>
              <n-icon :component="PersonOutline" size="20" />
            </n-button>
          </n-dropdown>
        </n-space>
      </template>
    </n-page-header>

    <!-- æœç´¢å’Œè¿‡æ»¤ -->
    <n-space class="search-bar" justify="space-between">
      <n-input 
        v-model:value="searchQuery"
        placeholder="æœç´¢å®¢æˆ·å§“åæˆ–ç”µè¯"
        clearable
        @input="handleSearch"
        style="max-width: 300px"
      >
        <template #prefix>
          <n-icon :component="SearchOutlined" />
        </template>
      </n-input>
      
      <n-button type="primary" @click="showCreateModal = true">
        <template #icon>
          <n-icon :component="PlusOutlined" />
        </template>
        æ·»åŠ å®¢æˆ·
      </n-button>
    </n-space>

    <!-- å®¢æˆ·åˆ—è¡¨ -->
    <n-spin :show="loading">
      <n-list bordered v-if="customers.length > 0">
        <n-list-item v-for="customer in customers" :key="customer.id">
          <CustomerCard 
            :customer="customer" 
            @click="goToDetail(customer.id)"
            @edit="handleEditCustomer"
            @delete="handleDeleteCustomer"
          />
        </n-list-item>
      </n-list>
      
      <n-empty 
        v-else-if="!loading" 
        description="æš‚æ— å®¢æˆ·æ•°æ®"
        size="large"
        style="margin: 40px 0"
      >
        <template #extra>
          <n-button size="small" @click="showCreateModal = true">
            åˆ›å»ºç¬¬ä¸€ä¸ªå®¢æˆ·
          </n-button>
        </template>
      </n-empty>
    </n-spin>

    <!-- åˆ†é¡µ -->
    <n-pagination
      v-if="customers.length > 0"
      v-model:page="currentPage"
      :page-count="totalPages"
      show-size-picker
      :page-sizes="[10, 20, 50]"
      :page-slot="7"
      @update:page="handlePageChange"
      @update:page-size="handlePageSizeChange"
    />

    <!-- åˆ›å»º/ç¼–è¾‘å®¢æˆ·å¼¹çª— -->
    <CustomerFormModal 
      v-model:show="showCreateModal"
      :customer="editingCustomer"
      @success="handleCustomerSaved"
    />
  </div>
</template>

<script setup lang="ts">
import { ref, reactive, onMounted, computed } from 'vue'
import { useRouter } from 'vue-router'
import { useMessage } from 'naive-ui'
import { 
  SearchOutlined, 
  PlusOutlined, 
  PersonOutline,
  LogOutOutline,
  SettingsOutline 
} from '@vicons/ionicons5'
import { useAuthStore } from '@/stores/auth'
import { customerApi } from '@/services/customer'
import type { CustomerWithLatestTrack } from '@/types/customer'
import CustomerCard from '@/components/CustomerCard.vue'
import CustomerFormModal from '@/components/CustomerFormModal.vue'

const router = useRouter()
const message = useMessage()
const authStore = useAuthStore()

// çŠ¶æ€ç®¡ç†
const loading = ref(false)
const customers = ref<CustomerWithLatestTrack[]>([])
const searchQuery = ref('')
const currentPage = ref(1)
const pageSize = ref(20)
const totalCount = ref(0)
const showCreateModal = ref(false)
const editingCustomer = ref<CustomerWithLatestTrack | null>(null)

// è®¡ç®—å±æ€§
const totalPages = computed(() => Math.ceil(totalCount.value / pageSize.value))

// ç”¨æˆ·èœå•é€‰é¡¹
const userMenuOptions = [
  {
    label: 'ä¸ªäººè®¾ç½®',
    key: 'settings',
    icon: () => h(SettingsOutline)
  },
  {
    type: 'divider'
  },
  {
    label: 'é€€å‡ºç™»å½•',
    key: 'logout',
    icon: () => h(LogOutOutline)
  }
]

// å¤„ç†ç”¨æˆ·èœå•é€‰æ‹©
const handleUserMenuSelect = (key: string) => {
  switch (key) {
    case 'settings':
      // TODO: æ‰“å¼€è®¾ç½®é¡µé¢
      message.info('ä¸ªäººè®¾ç½®åŠŸèƒ½å¼€å‘ä¸­')
      break
    case 'logout':
      handleLogout()
      break
  }
}

// é€€å‡ºç™»å½•
const handleLogout = async () => {
  await authStore.logout()
  message.success('å·²æˆåŠŸé€€å‡ºç™»å½•')
  router.push('/login')
}

// åŠ è½½å®¢æˆ·åˆ—è¡¨
const loadCustomers = async () => {
  try {
    loading.value = true
    const response = await customerApi.getCustomers({
      page: currentPage.value,
      limit: pageSize.value,
      search: searchQuery.value
    })
    
    customers.value = response.data.customers
    totalCount.value = response.data.total
  } catch (error) {
    message.error('åŠ è½½å®¢æˆ·åˆ—è¡¨å¤±è´¥')
  } finally {
    loading.value = false
  }
}

// å…¶ä»–äº‹ä»¶å¤„ç†å‡½æ•°...
const goToDetail = (customerId: number) => {
  router.push(`/customers/${customerId}`)
}

const handleEditCustomer = (customer: CustomerWithLatestTrack) => {
  editingCustomer.value = customer
  showCreateModal.value = true
}

const handleDeleteCustomer = async (customer: CustomerWithLatestTrack) => {
  // TODO: å®ç°åˆ é™¤ç¡®è®¤å¯¹è¯æ¡†
  try {
    await customerApi.deleteCustomer(customer.id)
    message.success('å®¢æˆ·åˆ é™¤æˆåŠŸ')
    loadCustomers()
  } catch (error) {
    message.error('åˆ é™¤å®¢æˆ·å¤±è´¥')
  }
}

const handleCustomerSaved = () => {
  showCreateModal.value = false
  editingCustomer.value = null
  loadCustomers()
}

const handleSearch = () => {
  currentPage.value = 1
  loadCustomers()
}

const handlePageChange = (page: number) => {
  currentPage.value = page
  loadCustomers()
}

const handlePageSizeChange = (size: number) => {
  pageSize.value = size
  currentPage.value = 1
  loadCustomers()
}

// é¡µé¢åŠ è½½
onMounted(() => {
  loadCustomers()
})
</script>

<style scoped>
.customer-list-container {
  padding: 16px;
  max-width: 1200px;
  margin: 0 auto;
}

.search-bar {
  margin: 24px 0;
  flex-direction: column;
}

@media (min-width: 768px) {
  .search-bar {
    flex-direction: row;
  }
}

.n-pagination {
  margin-top: 24px;
  justify-content: center;
}
</style>
```

---

## ğŸ“ é¡¹ç›®ç»“æ„

```
customer-tracker/
â”œâ”€â”€ backend/
â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â”œâ”€â”€ main.rs
â”‚   â”‚   â”œâ”€â”€ lib.rs
â”‚   â”‚   â”œâ”€â”€ cli.rs              # å‘½ä»¤è¡Œå·¥å…·
â”‚   â”‚   â”œâ”€â”€ config.rs           # é…ç½®ç®¡ç†
â”‚   â”‚   â”œâ”€â”€ database.rs         # æ•°æ®åº“è¿æ¥
â”‚   â”‚   â”œâ”€â”€ entities/           # Sea-ORMå®ä½“
â”‚   â”‚   â”‚   â”œâ”€â”€ mod.rs
â”‚   â”‚   â”‚   â”œâ”€â”€ user.rs
â”‚   â”‚   â”‚   â”œâ”€â”€ customer.rs
â”‚   â”‚   â”‚   â”œâ”€â”€ customer_track.rs
â”‚   â”‚   â”‚   â””â”€â”€ next_action.rs  # æšä¸¾å®šä¹‰
â”‚   â”‚   â”œâ”€â”€ handlers/           # HTTPå¤„ç†å™¨
â”‚   â”‚   â”‚   â”œâ”€â”€ mod.rs
â”‚   â”‚   â”‚   â”œâ”€â”€ auth.rs         # è®¤è¯ç›¸å…³
â”‚   â”‚   â”‚   â”œâ”€â”€ customer.rs
â”‚   â”‚   â”‚   â””â”€â”€ customer_track.rs
â”‚   â”‚   â”œâ”€â”€ services/           # ä¸šåŠ¡é€»è¾‘å±‚
â”‚   â”‚   â”‚   â”œâ”€â”€ mod.rs
â”‚   â”‚   â”‚   â”œâ”€â”€ auth_service.rs
â”‚   â”‚   â”‚   â”œâ”€â”€ customer_service.rs
â”‚   â”‚   â”‚   â””â”€â”€ track_service.rs
â”‚   â”‚   â”œâ”€â”€ middleware/         # ä¸­é—´ä»¶
â”‚   â”‚   â”‚   â”œâ”€â”€ mod.rs
â”‚   â”‚   â”‚   â””â”€â”€ auth.rs         # JWTè®¤è¯ä¸­é—´ä»¶
â”‚   â”‚   â”œâ”€â”€ utils/              # å·¥å…·å‡½æ•°
â”‚   â”‚   â”‚   â”œâ”€â”€ mod.rs
â”‚   â”‚   â”‚   â”œâ”€â”€ password.rs
â”‚   â”‚   â”‚   â”œâ”€â”€ jwt.rs          # JWTå·¥å…·
â”‚   â”‚   â”‚   â””â”€â”€ validation.rs   # æ•°æ®éªŒè¯
â”‚   â”‚   â””â”€â”€ routes.rs           # è·¯ç”±å®šä¹‰
â”‚   â”œâ”€â”€ migrations/             # æ•°æ®åº“è¿ç§»
â”‚   â”‚   â”œâ”€â”€ 001_create_users.sql
â”‚   â”‚   â”œâ”€â”€ 002_create_customers.sql
â”‚   â”‚   â””â”€â”€ 003_create_customer_tracks.sql
â”‚   â”œâ”€â”€ Cargo.toml
â”‚   â””â”€â”€ .env
â”œâ”€â”€ frontend/
â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â”œâ”€â”€ main.ts
â”‚   â”‚   â”œâ”€â”€ App.vue
â”‚   â”‚   â”œâ”€â”€ router/
â”‚   â”‚   â”‚   â””â”€â”€ index.ts        # è·¯ç”±é…ç½®å’Œå®ˆå«
â”‚   â”‚   â”œâ”€â”€ stores/             # PiniaçŠ¶æ€ç®¡ç†
â”‚   â”‚   â”‚   â”œâ”€â”€ auth.ts         # è®¤è¯çŠ¶æ€
â”‚   â”‚   â”‚   â”œâ”€â”€ customer.ts
â”‚   â”‚   â”‚   â””â”€â”€ track.ts
â”‚   â”‚   â”œâ”€â”€ views/              # é¡µé¢ç»„ä»¶
â”‚   â”‚   â”‚   â”œâ”€â”€ Login.vue       # ç™»å½•é¡µé¢
â”‚   â”‚   â”‚   â”œâ”€â”€ CustomerList.vue # å®¢æˆ·åˆ—è¡¨
â”‚   â”‚   â”‚   â””â”€â”€ CustomerDetail.vue
â”‚   â”‚   â”œâ”€â”€ components/         # å…¬å…±ç»„ä»¶
â”‚   â”‚   â”‚   â”œâ”€â”€ CustomerCard.vue
â”‚   â”‚   â”‚   â”œâ”€â”€ CustomerFormModal.vue
â”‚   â”‚   â”‚   â”œâ”€â”€ TrackTimeline.vue
â”‚   â”‚   â”‚   â”œâ”€â”€ NextActionSelect.vue
â”‚   â”‚   â”‚   â””â”€â”€ ProtectedRoute.vue # è·¯ç”±ä¿æŠ¤ç»„ä»¶
â”‚   â”‚   â”œâ”€â”€ services/           # APIæœåŠ¡
â”‚   â”‚   â”‚   â”œâ”€â”€ api.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ auth.ts         # è®¤è¯API
â”‚   â”‚   â”‚   â”œâ”€â”€ customer.ts
â”‚   â”‚   â”‚   â””â”€â”€ track.ts
â”‚   â”‚   â”œâ”€â”€ types/              # TypeScriptç±»å‹å®šä¹‰
â”‚   â”‚   â”‚   â”œâ”€â”€ auth.ts         # è®¤è¯ç›¸å…³ç±»å‹
â”‚   â”‚   â”‚   â”œâ”€â”€ customer.ts
â”‚   â”‚   â”‚   â””â”€â”€ track.ts
â”‚   â”‚   â””â”€â”€ utils/              # å·¥å…·å‡½æ•°
â”‚   â”‚       â”œâ”€â”€ format.ts
â”‚   â”‚       â”œâ”€â”€ request.ts      # HTTPè¯·æ±‚æ‹¦æˆªå™¨
â”‚   â”‚       â””â”€â”€ storage.ts      # æœ¬åœ°å­˜å‚¨å·¥å…·
â”‚   â”œâ”€â”€ package.json
â”‚   â”œâ”€â”€ vite.config.ts
â”‚   â”œâ”€â”€ tsconfig.json
â”‚   â””â”€â”€ .env.development
â”œâ”€â”€ README.md
â”œâ”€â”€ docker-compose.yml          # éƒ¨ç½²é…ç½®
â””â”€â”€ .github/workflows/          # CI/CDé…ç½®
    â””â”€â”€ deploy.yml
```

---

## ğŸ› ï¸ å¼€å‘è®¡åˆ’

### ç¬¬ä¸€é˜¶æ®µï¼šè®¤è¯ç³»ç»Ÿæ­å»º (1.5å‘¨)
- [ ] é¡¹ç›®åˆå§‹åŒ–å’Œä¾èµ–å®‰è£…
- [ ] æ•°æ®åº“æ¨¡å‹è®¾è®¡å’Œè¿ç§»
- [ ] JWTè®¤è¯ä¸­é—´ä»¶å®ç°
- [ ] ç”¨æˆ·ç™»å½•/ç™»å‡ºAPI
- [ ] å‰ç«¯ç™»å½•é¡µé¢å’Œè·¯ç”±å®ˆå«
- [ ] CLIç”¨æˆ·ç®¡ç†å·¥å…·

### ç¬¬äºŒé˜¶æ®µï¼šæ ¸å¿ƒåŠŸèƒ½å¼€å‘ (2å‘¨)
- [ ] å®¢æˆ·ä¿¡æ¯CRUD APIï¼ˆå¸¦æƒé™æ§åˆ¶ï¼‰
- [ ] å®¢æˆ·è¿½è¸ªè®°å½•APIï¼ˆå¸¦æƒé™æ§åˆ¶ï¼‰
- [ ] NextActionæšä¸¾ç±»å‹å®ç°
- [ ] å‰ç«¯è®¤è¯çŠ¶æ€ç®¡ç†
- [ ] å®¢æˆ·åˆ—è¡¨é¡µé¢ï¼ˆæ˜¾ç¤ºå½“å‰ç”¨æˆ·çš„å®¢æˆ·ï¼‰

### ç¬¬ä¸‰é˜¶æ®µï¼šç•Œé¢å®Œå–„å’Œä¼˜åŒ– (1.5å‘¨)
- [ ] å®¢æˆ·è¯¦æƒ…é¡µé¢å’Œæ—¶é—´çº¿
- [ ] NextActionçŠ¶æ€æ˜¾ç¤ºä¼˜åŒ–
- [ ] ç§»åŠ¨ç«¯å“åº”å¼ä¼˜åŒ–
- [ ] ç”¨æˆ·ä½“éªŒä¼˜åŒ–
- [ ] é”™è¯¯å¤„ç†å’ŒåŠ è½½çŠ¶æ€

### ç¬¬å››é˜¶æ®µï¼šæµ‹è¯•å’Œéƒ¨ç½² (1å‘¨)
- [ ] å•å…ƒæµ‹è¯•å’Œé›†æˆæµ‹è¯•
- [ ] æƒé™æ§åˆ¶è¾¹ç•Œæµ‹è¯•
- [ ] æ€§èƒ½ä¼˜åŒ–
- [ ] å®‰å…¨æ€§æµ‹è¯•
- [ ] Dockeréƒ¨ç½²é…ç½®
- [ ] æ–‡æ¡£å®Œå–„

---

## ğŸ”§ å¼€å‘ç¯å¢ƒé…ç½®

### åç«¯å¼€å‘ç¯å¢ƒ
```toml
# Cargo.toml
[dependencies]
axum = "0.8"
axum-extra = { version = "0.9", features = ["typed-header"] }
sea-orm = { version = "1.0", features = ["sqlx-sqlite", "runtime-tokio-rustls", "macros"] }
sqlx = { version = "0.8", features = ["runtime-tokio-rustls", "sqlite", "chrono"] }
tokio = { version = "1.0", features = ["full"] }
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
chrono = { version = "0.4", features = ["serde"] }
clap = { version = "4.0", features = ["derive"] }
jsonwebtoken = "9.0"
bcrypt = "0.15"
tracing = "0.1"
tracing-subscriber = "0.3"
dotenv = "0.15"
anyhow = "1.0"
thiserror = "1.0"
tower = "0.4"
tower-http = { version = "0.5", features = ["cors", "fs"] }
uuid = { version = "1.0", features = ["v4", "serde"] }
```

### å‰ç«¯å¼€å‘ç¯å¢ƒ
```json
{
  "dependencies": {
    "vue": "^3.4.0",
    "vue-router": "^4.2.0",
    "pinia": "^2.1.0",
    "naive-ui": "^2.35.0",
    "@vicons/ionicons5": "^0.12.0",
    "axios": "^1.6.0"
  },
  "devDependencies": {
    "@vitejs/plugin-vue": "^4.5.0",
    "vite": "^5.0.0",
    "typescript": "^5.2.0",
    "@types/node": "^20.8.0",
    "unplugin-auto-import": "^0.17.0",
    "unplugin-vue-components": "^0.26.0"
  }
}
```

### ç¯å¢ƒå˜é‡é…ç½®
```bash
# backend/.env
DATABASE_URL=sqlite://./customer_tracker.db
JWT_SECRET=your-super-secret-jwt-key-here-change-in-production-min-256-bits
JWT_EXPIRE_HOURS=24
LOG_LEVEL=debug
SERVER_HOST=0.0.0.0
SERVER_PORT=3000

# é»˜è®¤ç®¡ç†å‘˜è´¦æˆ·ï¼ˆä»…å¼€å‘ç¯å¢ƒï¼‰
ADMIN_USERNAME=admin
ADMIN_PASSWORD=admin123
ADMIN_NAME=ç³»ç»Ÿç®¡ç†å‘˜

# CORSé…ç½®
CORS_ORIGIN=http://localhost:5173
```

```bash
# frontend/.env.development
VITE_API_BASE_URL=http://localhost:3000
VITE_APP_TITLE=å®¢æˆ·è¿½è¸ªç³»ç»Ÿ
VITE_TOKEN_STORAGE_KEY=customer_tracker_token
```

### CLIå‘½ä»¤ç¤ºä¾‹
```rust
// src/cli.rs
use clap::{Args, Parser, Subcommand};
use crate::entities::next_action::NextAction;

#[derive(Parser)]
#[command(name = "customer-tracker")]
#[command(about = "å®¢æˆ·è¿½è¸ªç³»ç»Ÿç®¡ç†å·¥å…·")]
pub struct Cli {
    #[command(subcommand)]
    pub command: Commands,
}

#[derive(Subcommand)]
pub enum Commands {
    /// ç”¨æˆ·ç®¡ç†
    User(UserArgs),
    /// æ•°æ®åº“ç®¡ç†
    Database(DatabaseArgs),
    /// æœåŠ¡å™¨ç®¡ç†
    Server(ServerArgs),
}

#[derive(Args)]
pub struct UserArgs {
    #[command(subcommand)]
    pub action: UserAction,
}

#[derive(Subcommand)]
pub enum UserAction {
    /// åˆ›å»ºæ–°ç”¨æˆ·
    Create {
        #[arg(short, long)]
        username: String,
        #[arg(short, long)]
        password: String,
        #[arg(short, long)]
        name: String,
    },
    /// åˆ—å‡ºæ‰€æœ‰ç”¨æˆ·
    List {
        #[arg(short, long, default_value = "10")]
        limit: u32,
    },
    /// é‡ç½®ç”¨æˆ·å¯†ç 
    ResetPassword {
        #[arg(short, long)]
        username: String,
        #[arg(short, long)]
        password: String,
    },
    /// ç¦ç”¨/å¯ç”¨ç”¨æˆ·
    Toggle {
        #[arg(short, long)]
        username: String,
    },
}

#[derive(Args)]
pub struct DatabaseArgs {
    #[command(subcommand)]
    pub action: DatabaseAction,
}

#[derive(Subcommand)]
pub enum DatabaseAction {
    /// è¿è¡Œæ•°æ®åº“è¿ç§»
    Migrate,
    /// åˆ›å»ºè¿ç§»æ–‡ä»¶
    CreateMigration {
        #[arg(short, long)]
        name: String,
    },
    /// æ•°æ®åº“çŠ¶æ€
    Status,
}

#[derive(Args)]
pub struct ServerArgs {
    #[command(subcommand)]
    pub action: ServerAction,
}

#[derive(Subcommand)]
pub enum ServerAction {
    /// å¯åŠ¨æœåŠ¡å™¨
    Start {
        #[arg(short, long, default_value = "3000")]
        port: u16,
        #[arg(long, default_value = "127.0.0.1")]
        host: String,
    },
    /// ç”ŸæˆJWTå¯†é’¥
    GenerateJwtSecret,
}

// ä½¿ç”¨ç¤ºä¾‹ï¼š
// cargo run -- user create -u admin -p password123 -n "ç³»ç»Ÿç®¡ç†å‘˜"
// cargo run -- user list --limit 20
// cargo run -- database migrate
// cargo run -- server start --port 8080
// cargo run -- server generate-jwt-secret
```

### å¼€å‘å¯åŠ¨è„šæœ¬
```bash
# scripts/dev.sh
#!/bin/bash

echo "å¯åŠ¨å®¢æˆ·è¿½è¸ªç³»ç»Ÿå¼€å‘ç¯å¢ƒ..."

# æ£€æŸ¥æ˜¯å¦å®‰è£…äº†å¿…è¦çš„å·¥å…·
command -v cargo >/dev/null 2>&1 || { echo "è¯·å…ˆå®‰è£… Rust"; exit 1; }
command -v npm >/dev/null 2>&1 || { echo "è¯·å…ˆå®‰è£… Node.js"; exit 1; }

# å¯åŠ¨åç«¯
echo "å¯åŠ¨åç«¯æœåŠ¡..."
cd backend
if [ ! -f ".env" ]; then
    echo "åˆ›å»ºåç«¯ç¯å¢ƒå˜é‡æ–‡ä»¶..."
    cp .env.example .env
fi
cargo run -- database migrate
cargo run -- user create -u admin -p admin123 -n "ç®¡ç†å‘˜" 2>/dev/null || true
cargo run -- server start &
BACKEND_PID=$!

# ç­‰å¾…åç«¯å¯åŠ¨
sleep 3

# å¯åŠ¨å‰ç«¯
echo "å¯åŠ¨å‰ç«¯æœåŠ¡..."
cd ../frontend
if [ ! -f ".env.development" ]; then
    echo "åˆ›å»ºå‰ç«¯ç¯å¢ƒå˜é‡æ–‡ä»¶..."
    cp .env.development.example .env.development
fi
npm install
npm run dev &
FRONTEND_PID=$!

echo "å¼€å‘ç¯å¢ƒå·²å¯åŠ¨ï¼š"
echo "- åç«¯æœåŠ¡: http://localhost:3000"
echo "
