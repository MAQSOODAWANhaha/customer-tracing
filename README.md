# ÂÆ¢Êà∑ËøΩË∏™Á≥ªÁªüÈúÄÊ±ÇÊñáÊ°£

## üìã È°πÁõÆÊ¶ÇËø∞

### È°πÁõÆÂêçÁß∞
ÂÆ¢Êà∑ËøΩË∏™Á≥ªÁªü (Customer Tracking System)

### È°πÁõÆËÉåÊôØ
ÂºÄÂèë‰∏Ä‰∏™ÁÆÄÂçïÈ´òÊïàÁöÑÂÆ¢Êà∑ËøΩË∏™Á≥ªÁªüÔºåÂ∏ÆÂä©Áî®Êà∑ËÆ∞ÂΩïÂíåÁÆ°ÁêÜÂÆ¢Êà∑‰ø°ÊÅØÔºåË∑üË∏™ÂÆ¢Êà∑Ë∑üËøõÁä∂ÊÄÅÔºåÊèêÈ´òÂÆ¢Êà∑ÊúçÂä°Ë¥®ÈáèÂíåÈîÄÂîÆËΩ¨ÂåñÁéá„ÄÇÊîØÊåÅÂ§öÁî®Êà∑‰ΩøÁî®ÔºåÊØè‰∏™Áî®Êà∑Âè™ËÉΩÁÆ°ÁêÜËá™Â∑±ÂàõÂª∫ÁöÑÂÆ¢Êà∑‰ø°ÊÅØ„ÄÇ

### È°πÁõÆÁõÆÊ†á
- Êèê‰æõÂÆâÂÖ®ÁöÑÁî®Êà∑ËÆ§ËØÅÂíåÊùÉÈôêÊéßÂà∂Á≥ªÁªü
- Êèê‰æõÁÆÄÊ¥ÅÊòìÁî®ÁöÑÂÆ¢Êà∑‰ø°ÊÅØÁÆ°ÁêÜÁïåÈù¢
- ÊîØÊåÅÂÆ¢Êà∑Ë∑üËøõËÆ∞ÂΩïÁöÑÊó∂Èó¥Á∫øÂ±ïÁ§∫
- ‰ºòÂåñÁßªÂä®Á´ØÊµèËßàÂô®‰ΩìÈ™å
- Êèê‰æõÂø´ÈÄüÁöÑÊï∞ÊçÆÊü•ËØ¢ÂíåÂ±ïÁ§∫
- Á°Æ‰øùÊï∞ÊçÆÈöîÁ¶ªÔºåÊØè‰∏™Áî®Êà∑Âè™ËÉΩËÆøÈóÆËá™Â∑±ÁöÑÊï∞ÊçÆ

---

## üéØ ÂäüËÉΩÈúÄÊ±Ç

### 1. Áî®Êà∑ËÆ§ËØÅÁÆ°ÁêÜ
- **Áî®Êà∑ÁôªÂΩïÈ°µÈù¢**ÔºöÊèê‰æõÁî®Êà∑Âêç/ÂØÜÁ†ÅÁôªÂΩïÁïåÈù¢
- **JWTËÆ§ËØÅ**ÔºöÂü∫‰∫éJWT TokenÁöÑË∫´‰ªΩÈ™åËØÅ
- **Ëá™Âä®ÁôªÂΩï**ÔºöËÆ∞‰ΩèÁôªÂΩïÁä∂ÊÄÅÔºåÊîØÊåÅTokenËá™Âä®Áª≠Êúü
- **ÁôªÂá∫ÂäüËÉΩ**ÔºöÂÆâÂÖ®ÈÄÄÂá∫Âπ∂Ê∏ÖÈô§ËÆ§ËØÅ‰ø°ÊÅØ
- **Ë∑ØÁî±‰øùÊä§**ÔºöÊú™ËÆ§ËØÅÁî®Êà∑Ëá™Âä®Ë∑≥ËΩ¨Âà∞ÁôªÂΩïÈ°µ
- **ÂëΩ‰ª§Ë°åÁî®Êà∑ÁÆ°ÁêÜ**ÔºöÊîØÊåÅÈÄöËøáCLIÊ∑ªÂä†Áî®Êà∑

### 2. ÂÆ¢Êà∑‰ø°ÊÅØÁÆ°ÁêÜ
- **ÂÆ¢Êà∑ÂàóË°®Â±ïÁ§∫**ÔºöÂàÜÈ°µÊòæÁ§∫ÂΩìÂâçÁî®Êà∑ÁöÑÂÆ¢Êà∑Âü∫Êú¨‰ø°ÊÅØ
- **ÂÆ¢Êà∑‰ø°ÊÅØÂΩïÂÖ•**ÔºöÊ∑ªÂä†Êñ∞ÂÆ¢Êà∑‰ø°ÊÅØÔºàËá™Âä®ÂÖ≥ËÅîÂΩìÂâçÁî®Êà∑Ôºâ
- **ÂÆ¢Êà∑‰ø°ÊÅØÁºñËæë**Ôºö‰øÆÊîπÂÆ¢Êà∑Âü∫Êú¨‰ø°ÊÅØÔºà‰ªÖÈôêËá™Â∑±ÂàõÂª∫ÁöÑÂÆ¢Êà∑Ôºâ
- **ÂÆ¢Êà∑‰ø°ÊÅØÂà†Èô§**ÔºöÂà†Èô§ÂÆ¢Êà∑ËÆ∞ÂΩïÔºà‰ªÖÈôêËá™Â∑±ÂàõÂª∫ÁöÑÂÆ¢Êà∑ÔºåËΩØÂà†Èô§Ôºâ
- **Êï∞ÊçÆÈöîÁ¶ª**ÔºöÁî®Êà∑Âè™ËÉΩÊü•ÁúãÂíåÊìç‰ΩúËá™Â∑±ÂàõÂª∫ÁöÑÂÆ¢Êà∑

### 3. ÂÆ¢Êà∑ËøΩË∏™ÁÆ°ÁêÜ  
- **ËøΩË∏™ËÆ∞ÂΩïÊ∑ªÂä†**Ôºö‰∏∫Ëá™Â∑±ÁöÑÂÆ¢Êà∑Ê∑ªÂä†Ë∑üËøõËÆ∞ÂΩï
- **ËøΩË∏™ËÆ∞ÂΩïÊü•Áúã**ÔºöÊó∂Èó¥Á∫øÊñπÂºèÂ±ïÁ§∫Ë∑üËøõÂéÜÂè≤
- **ËøΩË∏™ËÆ∞ÂΩïÁºñËæë**Ôºö‰øÆÊîπË∑üËøõËÆ∞ÂΩïÂÜÖÂÆπ
- **‰∏ãÊ¨°Ë∑üËøõÂä®‰Ωú**ÔºöÈÄâÊã©ÁªßÁª≠Ë∑üËøõÊàñÁªìÊùüË∑üËøõ
- **ÊùÉÈôêÊéßÂà∂**ÔºöÂè™ËÉΩÊìç‰ΩúËá™Â∑±ÂÆ¢Êà∑ÁöÑË∑üËøõËÆ∞ÂΩï

---

## üíª ÊäÄÊúØÊû∂ÊûÑ

### ÂêéÁ´ØÊäÄÊúØÊ†à
```yaml
ËØ≠Ë®Ä: Rust Edition 2021/2024
WebÊ°ÜÊû∂: Axum 0.8.x
Êï∞ÊçÆÂ∫ì: SQLite (ÊúÄÊñ∞ÁâàÊú¨)
ORM: Sea-ORM (ÊúÄÊñ∞ÁâàÊú¨) 
ÂëΩ‰ª§Ë°å: Clap 4.x
ËÆ§ËØÅ: JWT Token (jsonwebtoken)
ÂØÜÁ†ÅÂä†ÂØÜ: bcrypt
‰∏≠Èó¥‰ª∂: axum-extra (JWT middleware)
Êó•Âøó: tracing
ÈÖçÁΩÆ: config/dotenv
```

### ÂâçÁ´ØÊäÄÊúØÊ†à
```yaml
Ê°ÜÊû∂: Vue 3.x (Composition API)
UIÁªÑ‰ª∂Â∫ì: Naive UI
Áä∂ÊÄÅÁÆ°ÁêÜ: Pinia
Ë∑ØÁî±: Vue Router 4.x (Ë∑ØÁî±ÂÆàÂç´)
HTTPÂÆ¢Êà∑Á´Ø: Axios (ËØ∑Ê±Ç/ÂìçÂ∫îÊã¶Êà™Âô®)
ÊûÑÂª∫Â∑•ÂÖ∑: Vite
Á±ªÂûãÊ£ÄÊü•: TypeScript
Êú¨Âú∞Â≠òÂÇ®: localStorage (TokenÂ≠òÂÇ®)
```

### ÈÉ®ÁΩ≤ÁéØÂ¢É
```yaml
ÁõÆÊ†áËÆæÂ§á: ÁßªÂä®Á´ØÊµèËßàÂô®‰ºòÂÖà
ÂÖºÂÆπÊÄß: Áé∞‰ª£ÊµèËßàÂô® (Chrome, Safari, Firefox)
ÂìçÂ∫îÂºè: ÁßªÂä®Á´Ø‰ºòÂÖàËÆæËÆ°
```

---

## üóÉÔ∏è Êï∞ÊçÆÊ®°ÂûãËÆæËÆ°

### 1. Áî®Êà∑Ë°® (users)
```sql
CREATE TABLE users (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    username VARCHAR(50) UNIQUE NOT NULL,
    password_hash VARCHAR(255) NOT NULL,
    name VARCHAR(100) NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    is_active BOOLEAN DEFAULT TRUE,
    last_login_at TIMESTAMP NULL
);

CREATE INDEX idx_users_username ON users(username);
CREATE INDEX idx_users_is_active ON users(is_active);
```

### 2. ÂÆ¢Êà∑Ë°® (customers)
```sql
CREATE TABLE customers (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    name VARCHAR(100) NOT NULL,
    phone VARCHAR(20),
    address TEXT,
    notes TEXT,
    rate INTEGER DEFAULT 0 CHECK(rate >= 0 AND rate <= 5),
    user_id INTEGER NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    is_deleted BOOLEAN DEFAULT FALSE,
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
);

CREATE INDEX idx_customers_user_id ON customers(user_id);
CREATE INDEX idx_customers_is_deleted ON customers(is_deleted);
CREATE INDEX idx_customers_name ON customers(name);
```

### 3. ÂÆ¢Êà∑ËøΩË∏™ËÆ∞ÂΩïË°® (customer_tracks)
```sql
CREATE TABLE customer_tracks (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    customer_id INTEGER NOT NULL,
    content TEXT NOT NULL,
    next_action VARCHAR(64) DEFAULT 'ÁªßÁª≠Ë∑üËøõ' CHECK(next_action IN ('ÁªßÁª≠Ë∑üËøõ', 'ÁªìÊùüË∑üËøõ')),
    track_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    next_track_time TIMESTAMP,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (customer_id) REFERENCES customers(id) ON DELETE CASCADE
);

CREATE INDEX idx_customer_tracks_customer_id ON customer_tracks(customer_id);
CREATE INDEX idx_customer_tracks_track_time ON customer_tracks(track_time);
```

### 4. Sea-ORM ÂÆû‰ΩìÂÆö‰πâ

#### User Entity
```rust
use sea_orm::entity::prelude::*;
use serde::{Deserialize, Serialize};

#[derive(Clone, Debug, PartialEq, DeriveEntityModel, Serialize, Deserialize)]
#[sea_orm(table_name = "users")]
pub struct Model {
    #[sea_orm(primary_key)]
    pub id: i32,
    #[sea_orm(unique)]
    pub username: String,
    #[serde(skip_serializing)]
    pub password_hash: String,
    pub name: String,
    pub created_at: ChronoDateTimeUtc,
    pub updated_at: ChronoDateTimeUtc,
    pub is_active: bool,
    pub last_login_at: Option<ChronoDateTimeUtc>,
}

#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
pub enum Relation {
    #[sea_orm(has_many = "super::customer::Entity")]
    Customer,
}

impl Related<super::customer::Entity> for Entity {
    fn to() -> RelationDef {
        Relation::Customer.def()
    }
}

impl ActiveModelBehavior for ActiveModel {}
```

#### Customer Entity
```rust
use sea_orm::entity::prelude::*;
use serde::{Deserialize, Serialize};

#[derive(Clone, Debug, PartialEq, DeriveEntityModel, Serialize, Deserialize)]
#[sea_orm(table_name = "customers")]
pub struct Model {
    #[sea_orm(primary_key)]
    pub id: i32,
    pub name: String,
    pub phone: Option<String>,
    pub address: Option<String>,
    pub notes: Option<String>,
    pub rate: i32,
    pub user_id: i32,
    pub created_at: ChronoDateTimeUtc,
    pub updated_at: ChronoDateTimeUtc,
    pub is_deleted: bool,
}

#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
pub enum Relation {
    #[sea_orm(belongs_to = "super::user::Entity", from = "Column::UserId", to = "super::user::Column::Id")]
    User,
    #[sea_orm(has_many = "super::customer_track::Entity")]
    CustomerTrack,
}

impl Related<super::user::Entity> for Entity {
    fn to() -> RelationDef {
        Relation::User.def()
    }
}

impl Related<super::customer_track::Entity> for Entity {
    fn to() -> RelationDef {
        Relation::CustomerTrack.def()
    }
}

impl ActiveModelBehavior for ActiveModel {}
```

#### NextAction Enum
```rust
use sea_orm::entity::prelude::*;
use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, PartialEq, Eq, EnumIter, DeriveActiveEnum, Serialize, Deserialize)]
#[sea_orm(rs_type = "String", db_type = "String(Some(64))")]
pub enum NextAction {
    #[sea_orm(string_value = "ÁªßÁª≠Ë∑üËøõ")]
    Continue,
    #[sea_orm(string_value = "ÁªìÊùüË∑üËøõ")]
    End,
}

impl Default for NextAction {
    fn default() -> Self {
        NextAction::Continue
    }
}

impl NextAction {
    pub fn as_str(&self) -> &str {
        match self {
            NextAction::Continue => "ÁªßÁª≠Ë∑üËøõ",
            NextAction::End => "ÁªìÊùüË∑üËøõ",
        }
    }
    
    pub fn from_str(s: &str) -> Option<Self> {
        match s {
            "ÁªßÁª≠Ë∑üËøõ" => Some(NextAction::Continue),
            "ÁªìÊùüË∑üËøõ" => Some(NextAction::End),
            _ => None,
        }
    }
    
    pub fn variants() -> Vec<&'static str> {
        vec!["ÁªßÁª≠Ë∑üËøõ", "ÁªìÊùüË∑üËøõ"]
    }
}
```

#### CustomerTrack Entity
```rust
use sea_orm::entity::prelude::*;
use serde::{Deserialize, Serialize};
use super::next_action::NextAction;

#[derive(Clone, Debug, PartialEq, DeriveEntityModel, Serialize, Deserialize)]
#[sea_orm(table_name = "customer_tracks")]
pub struct Model {
    #[sea_orm(primary_key)]
    pub id: i32,
    pub customer_id: i32,
    pub content: String,
    pub next_action: NextAction,
    pub track_time: ChronoDateTimeUtc,
    pub next_track_time: Option<ChronoDateTimeUtc>,
    pub created_at: ChronoDateTimeUtc,
    pub updated_at: ChronoDateTimeUtc,
}

#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
pub enum Relation {
    #[sea_orm(belongs_to = "super::customer::Entity", from = "Column::CustomerId", to = "super::customer::Column::Id")]
    Customer,
}

impl Related<super::customer::Entity> for Entity {
    fn to() -> RelationDef {
        Relation::Customer.def()
    }
}

impl ActiveModelBehavior for ActiveModel {}
```

---

## üîå APIÊé•Âè£ËÆæËÆ°

### 1. JWTËÆ§ËØÅ‰∏≠Èó¥‰ª∂
```rust
use axum::{
    extract::{Request, State},
    http::{header::AUTHORIZATION, StatusCode},
    middleware::Next,
    response::Response,
    Extension,
};
use jsonwebtoken::{decode, DecodingKey, Validation};
use serde::{Deserialize, Serialize};

#[derive(Debug, Serialize, Deserialize)]
pub struct Claims {
    pub user_id: i32,
    pub username: String,
    pub name: String,
    pub exp: usize,
    pub iat: usize,
}

#[derive(Debug, Clone)]
pub struct CurrentUser {
    pub id: i32,
    pub username: String,
    pub name: String,
}

pub async fn auth_middleware(
    State(app_state): State<AppState>,
    mut request: Request,
    next: Next,
) -> Result<Response, StatusCode> {
    let auth_header = request
        .headers()
        .get(AUTHORIZATION)
        .and_then(|header| header.to_str().ok())
        .and_then(|header| header.strip_prefix("Bearer "));

    let token = match auth_header {
        Some(token) => token,
        None => return Err(StatusCode::UNAUTHORIZED),
    };

    let claims = decode::<Claims>(
        token,
        &DecodingKey::from_secret(app_state.jwt_secret.as_ref()),
        &Validation::default(),
    )
    .map_err(|_| StatusCode::UNAUTHORIZED)?;

    let current_user = CurrentUser {
        id: claims.claims.user_id,
        username: claims.claims.username,
        name: claims.claims.name,
    };

    request.extensions_mut().insert(current_user);
    Ok(next.run(request).await)
}
```

### 2. ËÆ§ËØÅÁõ∏ÂÖ≥API
```rust
// POST /api/auth/login
#[derive(Debug, Deserialize)]
pub struct LoginRequest {
    pub username: String,
    pub password: String,
}

#[derive(Debug, Serialize)]
pub struct LoginResponse {
    pub token: String,
    pub expires_in: i64,
    pub user: UserInfo,
}

#[derive(Debug, Serialize)]
pub struct UserInfo {
    pub id: i32,
    pub username: String,
    pub name: String,
    pub last_login_at: Option<ChronoDateTimeUtc>,
}

// POST /api/auth/refresh - Âà∑Êñ∞Token
#[derive(Debug, Serialize)]
pub struct RefreshTokenResponse {
    pub token: String,
    pub expires_in: i64,
}

// POST /api/auth/logout
#[derive(Debug, Serialize)]
pub struct LogoutResponse {
    pub message: String,
}

// GET /api/auth/me - Ëé∑ÂèñÂΩìÂâçÁî®Êà∑‰ø°ÊÅØ
pub async fn get_current_user(
    Extension(current_user): Extension<CurrentUser>,
) -> Result<Json<UserInfo>, StatusCode> {
    Ok(Json(UserInfo {
        id: current_user.id,
        username: current_user.username,
        name: current_user.name,
        last_login_at: None, // ‰ªéÊï∞ÊçÆÂ∫ìËé∑Âèñ
    }))
}
```

### 3. ÂÆ¢Êà∑ÁÆ°ÁêÜAPIÔºàÂ∏¶ÊùÉÈôêÊéßÂà∂Ôºâ
```rust
use crate::entities::next_action::NextAction;
use axum::Extension;

// GET /api/customers?page=1&limit=20&search=
#[derive(Debug, Serialize)]
pub struct CustomerListResponse {
    pub customers: Vec<CustomerWithLatestTrack>,
    pub total: u64,
    pub page: u32,
    pub limit: u32,
}

#[derive(Debug, Serialize)]
pub struct CustomerWithLatestTrack {
    pub id: i32,
    pub name: String,
    pub phone: Option<String>,
    pub rate: i32,
    pub notes: Option<String>,
    pub latest_track_time: Option<ChronoDateTimeUtc>,
    pub latest_next_action: Option<NextAction>,
    pub latest_content: Option<String>,
    pub created_at: ChronoDateTimeUtc,
}

// ÂÆ¢Êà∑ÂàóË°®Â§ÑÁêÜÂô®ÔºàÂè™ËøîÂõûÂΩìÂâçÁî®Êà∑ÁöÑÂÆ¢Êà∑Ôºâ
pub async fn list_customers(
    Extension(current_user): Extension<CurrentUser>,
    Query(params): Query<CustomerListQuery>,
    State(app_state): State<AppState>,
) -> Result<Json<CustomerListResponse>, StatusCode> {
    let customers = Customer::find()
        .filter(customer::Column::UserId.eq(current_user.id))
        .filter(customer::Column::IsDeleted.eq(false))
        // Ê∑ªÂä†ÊêúÁ¥¢ËøáÊª§
        .apply_if(params.search, |query, search| {
            query.filter(
                customer::Column::Name.contains(&search)
                    .or(customer::Column::Phone.contains(&search))
            )
        })
        .order_by_desc(customer::Column::UpdatedAt)
        .paginate(&app_state.db, params.limit as u64);

    // Ëé∑ÂèñÂàÜÈ°µÊï∞ÊçÆÂíåÊÄªÊï∞
    let customers_page = customers.fetch_page(params.page as u64 - 1).await
        .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;
    
    let total = customers.num_items().await
        .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;

    // ... Â§ÑÁêÜÊúÄÊñ∞Ë∑üËøõËÆ∞ÂΩïÂÖ≥ËÅîÊü•ËØ¢
    
    Ok(Json(CustomerListResponse {
        customers: customer_with_tracks,
        total,
        page: params.page,
        limit: params.limit,
    }))
}

// POST /api/customers - ÂàõÂª∫ÂÆ¢Êà∑ÔºàËá™Âä®ÂÖ≥ËÅîÂΩìÂâçÁî®Êà∑Ôºâ
#[derive(Debug, Deserialize)]
pub struct CreateCustomerRequest {
    pub name: String,
    pub phone: Option<String>,
    pub address: Option<String>,
    pub notes: Option<String>,
    pub rate: Option<i32>,
}

pub async fn create_customer(
    Extension(current_user): Extension<CurrentUser>,
    State(app_state): State<AppState>,
    Json(req): Json<CreateCustomerRequest>,
) -> Result<Json<Customer>, StatusCode> {
    let customer = customer::ActiveModel {
        name: Set(req.name),
        phone: Set(req.phone),
        address: Set(req.address),
        notes: Set(req.notes),
        rate: Set(req.rate.unwrap_or(0)),
        user_id: Set(current_user.id), // Ëá™Âä®ÂÖ≥ËÅîÂΩìÂâçÁî®Êà∑
        created_at: Set(Utc::now()),
        updated_at: Set(Utc::now()),
        ..Default::default()
    };

    let customer = customer.insert(&app_state.db).await
        .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;

    Ok(Json(customer))
}

// PUT /api/customers/:id - Êõ¥Êñ∞ÂÆ¢Êà∑ÔºàÂè™ËÉΩÊõ¥Êñ∞Ëá™Â∑±ÁöÑÂÆ¢Êà∑Ôºâ
pub async fn update_customer(
    Extension(current_user): Extension<CurrentUser>,
    Path(customer_id): Path<i32>,
    State(app_state): State<AppState>,
    Json(req): Json<UpdateCustomerRequest>,
) -> Result<Json<Customer>, StatusCode> {
    // Ê£ÄÊü•ÂÆ¢Êà∑ÊòØÂê¶Â±û‰∫éÂΩìÂâçÁî®Êà∑
    let customer = Customer::find_by_id(customer_id)
        .filter(customer::Column::UserId.eq(current_user.id))
        .filter(customer::Column::IsDeleted.eq(false))
        .one(&app_state.db)
        .await
        .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?
        .ok_or(StatusCode::NOT_FOUND)?;

    // ÊâßË°åÊõ¥Êñ∞Êìç‰Ωú
    let mut customer: customer::ActiveModel = customer.into();
    
    if let Some(name) = req.name {
        customer.name = Set(name);
    }
    // ... ÂÖ∂‰ªñÂ≠óÊÆµÊõ¥Êñ∞
    customer.updated_at = Set(Utc::now());

    let updated_customer = customer.update(&app_state.db).await
        .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;

    Ok(Json(updated_customer))
}
```

### 4. ÂÆ¢Êà∑ËøΩË∏™APIÔºàÂ∏¶ÊùÉÈôêÊéßÂà∂Ôºâ
```rust
// GET /api/customers/:id/tracks - Ëé∑ÂèñÂÆ¢Êà∑Ë∑üËøõËÆ∞ÂΩï
pub async fn list_customer_tracks(
    Extension(current_user): Extension<CurrentUser>,
    Path(customer_id): Path<i32>,
    State(app_state): State<AppState>,
) -> Result<Json<CustomerTrackListResponse>, StatusCode> {
    // È¶ñÂÖàÈ™åËØÅÂÆ¢Êà∑ÊòØÂê¶Â±û‰∫éÂΩìÂâçÁî®Êà∑
    let customer = Customer::find_by_id(customer_id)
        .filter(customer::Column::UserId.eq(current_user.id))
        .filter(customer::Column::IsDeleted.eq(false))
        .one(&app_state.db)
        .await
        .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?
        .ok_or(StatusCode::NOT_FOUND)?;

    // Ëé∑ÂèñË∑üËøõËÆ∞ÂΩï
    let tracks = CustomerTrack::find()
        .filter(customer_track::Column::CustomerId.eq(customer_id))
        .order_by_desc(customer_track::Column::TrackTime)
        .all(&app_state.db)
        .await
        .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;

    Ok(Json(CustomerTrackListResponse {
        tracks: tracks.into_iter().map(|t| CustomerTrackInfo::from(t)).collect(),
        customer: CustomerInfo::from(customer),
    }))
}

// POST /api/customers/:id/tracks - ÂàõÂª∫Ë∑üËøõËÆ∞ÂΩï
pub async fn create_customer_track(
    Extension(current_user): Extension<CurrentUser>,
    Path(customer_id): Path<i32>,
    State(app_state): State<AppState>,
    Json(req): Json<CreateTrackRequest>,
) -> Result<Json<CustomerTrackInfo>, StatusCode> {
    // È™åËØÅÂÆ¢Êà∑ÊòØÂê¶Â±û‰∫éÂΩìÂâçÁî®Êà∑
    let _customer = Customer::find_by_id(customer_id)
        .filter(customer::Column::UserId.eq(current_user.id))
        .filter(customer::Column::IsDeleted.eq(false))
        .one(&app_state.db)
        .await
        .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?
        .ok_or(StatusCode::NOT_FOUND)?;

    let track = customer_track::ActiveModel {
        customer_id: Set(customer_id),
        content: Set(req.content),
        next_action: Set(req.next_action.unwrap_or(NextAction::Continue)),
        track_time: Set(req.track_time.unwrap_or_else(|| Utc::now())),
        next_track_time: Set(req.next_track_time),
        created_at: Set(Utc::now()),
        updated_at: Set(Utc::now()),
        ..Default::default()
    };

    let track = track.insert(&app_state.db).await
        .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;

    Ok(Json(CustomerTrackInfo::from(track)))
}
```

### 5. AxumË∑ØÁî±ÂÆö‰πâ
```rust
use axum::{
    routing::{get, post, put, delete},
    Router, middleware,
};
use tower_http::cors::CorsLayer;

pub fn create_routes(app_state: AppState) -> Router {
    Router::new()
        // ÂÖ¨ÂºÄË∑ØÁî±ÔºàÊó†ÈúÄËÆ§ËØÅÔºâ
        .route("/api/auth/login", post(auth::login))
        .route("/api/health", get(|| async { "OK" }))
        
        // Âèó‰øùÊä§Ë∑ØÁî±ÔºàÈúÄË¶ÅËÆ§ËØÅÔºâ
        .route("/api/auth/me", get(auth::get_current_user))
        .route("/api/auth/logout", post(auth::logout))
        .route("/api/auth/refresh", post(auth::refresh_token))
        
        // ÂÆ¢Êà∑Ë∑ØÁî±
        .route("/api/customers", get(customer::list).post(customer::create))
        .route("/api/customers/:id", 
            get(customer::get)
            .put(customer::update)
            .delete(customer::delete)
        )
        
        // ÂÆ¢Êà∑ËøΩË∏™Ë∑ØÁî±
        .route("/api/customers/:id/tracks", 
            get(customer_track::list)
            .post(customer_track::create)
        )
        .route("/api/tracks/:id", 
            put(customer_track::update)
            .delete(customer_track::delete)
        )
        .route("/api/tracks/actions", get(customer_track::get_next_actions))
        
        // ÂØπÂèó‰øùÊä§Ë∑ØÁî±Â∫îÁî®ËÆ§ËØÅ‰∏≠Èó¥‰ª∂
        .layer(middleware::from_fn_with_state(app_state.clone(), auth_middleware))
        
        // CORS‰∏≠Èó¥‰ª∂
        .layer(CorsLayer::permissive())
        
        // ÈùôÊÄÅÊñá‰ª∂ÊúçÂä°
        .fallback_service(ServeDir::new("dist"))
        
        .with_state(app_state)
}

// ÈúÄË¶ÅÂ∞ÜÂÖ¨ÂºÄË∑ØÁî±‰ªéËÆ§ËØÅ‰∏≠Èó¥‰ª∂‰∏≠ÊéíÈô§
pub fn create_routes_with_auth(app_state: AppState) -> Router {
    let public_routes = Router::new()
        .route("/api/auth/login", post(auth::login))
        .route("/api/health", get(|| async { "OK" }))
        .with_state(app_state.clone());

    let protected_routes = Router::new()
        .route("/api/auth/me", get(auth::get_current_user))
        .route("/api/auth/logout", post(auth::logout))
        .route("/api/auth/refresh", post(auth::refresh_token))
        .route("/api/customers", get(customer::list).post(customer::create))
        .route("/api/customers/:id", 
            get(customer::get).put(customer::update).delete(customer::delete))
        .route("/api/customers/:id/tracks", 
            get(customer_track::list).post(customer_track::create))
        .route("/api/tracks/:id", 
            put(customer_track::update).delete(customer_track::delete))
        .route("/api/tracks/actions", get(customer_track::get_next_actions))
        .layer(middleware::from_fn_with_state(
            app_state.clone(), 
            auth_middleware
        ))
        .with_state(app_state.clone());

    Router::new()
        .merge(public_routes)
        .merge(protected_routes)
        .layer(CorsLayer::permissive())
        .fallback_service(ServeDir::new("dist"))
}
```

---

## üé® ÂâçÁ´ØÁïåÈù¢ËÆæËÆ°

### 1. TypeScript Á±ªÂûãÂÆö‰πâ
```typescript
// types/auth.ts
export interface User {
  id: number
  username: string
  name: string
  last_login_at?: string
}

export interface LoginRequest {
  username: string
  password: string
}

export interface LoginResponse {
  token: string
  expires_in: number
  user: User
}

export interface AuthState {
  token: string | null
  user: User | null
  isAuthenticated: boolean
}

// types/customer.ts
export interface Customer {
  id: number
  name: string
  phone?: string
  address?: string
  notes?: string
  rate: number
  user_id: number
  created_at: string
  updated_at: string
}

export interface CustomerWithLatestTrack extends Customer {
  latest_track_time?: string
  latest_next_action?: NextAction
  latest_content?: string
}
```

### 2. ËÆ§ËØÅÁä∂ÊÄÅÁÆ°ÁêÜ (Pinia Store)
```typescript
// stores/auth.ts
import { defineStore } from 'pinia'
import { ref, computed } from 'vue'
import { authApi } from '@/services/auth'
import type { User, AuthState, LoginRequest } from '@/types/auth'

export const useAuthStore = defineStore('auth', () => {
  const token = ref<string | null>(localStorage.getItem('token'))
  const user = ref<User | null>(null)

  const isAuthenticated = computed(() => !!token.value && !!user.value)

  // ÂàùÂßãÂåñËÆ§ËØÅÁä∂ÊÄÅ
  const initAuth = async () => {
    const savedToken = localStorage.getItem('token')
    if (savedToken) {
      token.value = savedToken
      try {
        const response = await authApi.getCurrentUser()
        user.value = response.data
        return true
      } catch (error) {
        // TokenÊó†ÊïàÔºåÊ∏ÖÈô§Êú¨Âú∞Â≠òÂÇ®
        logout()
        return false
      }
    }
    return false
  }

  // ÁôªÂΩï
  const login = async (credentials: LoginRequest) => {
    try {
      const response = await authApi.login(credentials)
      token.value = response.data.token
      user.value = response.data.user
      
      // ‰øùÂ≠òÂà∞Êú¨Âú∞Â≠òÂÇ®
      localStorage.setItem('token', response.data.token)
      
      return { success: true, user: response.data.user }
    } catch (error: any) {
      return { 
        success: false, 
        message: error.response?.data?.message || 'ÁôªÂΩïÂ§±Ë¥•' 
      }
    }
  }

  // ÁôªÂá∫
  const logout = async () => {
    try {
      if (token.value) {
        await authApi.logout()
      }
    } catch (error) {
      // ÂøΩÁï•ÁôªÂá∫APIÈîôËØØ
    } finally {
      token.value = null
      user.value = null
      localStorage.removeItem('token')
    }
  }

  // Âà∑Êñ∞Token
  const refreshToken = async () => {
    try {
      const response = await authApi.refreshToken()
      token.value = response.data.token
      localStorage.setItem('token', response.data.token)
      return true
    } catch (error) {
      logout()
      return false
    }
  }

  return {
    token,
    user,
    isAuthenticated,
    initAuth,
    login,
    logout,
    refreshToken
  }
})
```

### 3. ÁôªÂΩïÈ°µÈù¢
```vue
<!-- views/Login.vue -->
<template>
  <div class="login-container">
    <div class="login-card">
      <n-card title="ÂÆ¢Êà∑ËøΩË∏™Á≥ªÁªü" size="large">
        <template #header-extra>
          <n-icon :component="PersonCircleOutline" size="24" />
        </template>
        
        <n-form
          ref="loginFormRef"
          :model="loginForm"
          :rules="loginFormRules"
          size="large"
          :show-require-mark="false"
        >
          <n-form-item path="username">
            <n-input
              v-model:value="loginForm.username"
              placeholder="ËØ∑ËæìÂÖ•Áî®Êà∑Âêç"
              clearable
              @keydown.enter="handleLogin"
            >
              <template #prefix>
                <n-icon :component="PersonOutline" />
              </template>
            </n-input>
          </n-form-item>
          
          <n-form-item path="password">
            <n-input
              v-model:value="loginForm.password"
              type="password"
              placeholder="ËØ∑ËæìÂÖ•ÂØÜÁ†Å"
              show-password-on="click"
              @keydown.enter="handleLogin"
            >
              <template #prefix>
                <n-icon :component="LockClosedOutline" />
              </template>
            </n-input>
          </n-form-item>
          
          <n-form-item>
            <n-checkbox v-model:checked="rememberMe">
              ËÆ∞‰ΩèÁôªÂΩïÁä∂ÊÄÅ
            </n-checkbox>
          </n-form-item>
        </n-form>
        
        <template #action>
          <n-space vertical size="large" style="width: 100%">
            <n-button
              type="primary"
              size="large"
              block
              :loading="loginLoading"
              @click="handleLogin"
            >
              ÁôªÂΩï
            </n-button>
            
            <n-text depth="3" style="text-align: center; display: block">
              ÂÆ¢Êà∑ËøΩË∏™ÁÆ°ÁêÜÁ≥ªÁªü v1.0
            </n-text>
          </n-space>
        </template>
      </n-card>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, reactive, onMounted } from 'vue'
import { useRouter, useRoute } from 'vue-router'
import { useMessage, type FormInst, type FormRules } from 'naive-ui'
import { PersonCircleOutline, PersonOutline, LockClosedOutline } from '@vicons/ionicons5'
import { useAuthStore } from '@/stores/auth'
import type { LoginRequest } from '@/types/auth'

const router = useRouter()
const route = useRoute()
const message = useMessage()
const authStore = useAuthStore()

const loginFormRef = ref<FormInst | null>(null)
const loginLoading = ref(false)
const rememberMe = ref(true)

const loginForm = reactive<LoginRequest>({
  username: '',
  password: ''
})

const loginFormRules: FormRules = {
  username: [
    { required: true, message: 'ËØ∑ËæìÂÖ•Áî®Êà∑Âêç', trigger: ['input', 'blur'] },
    { min: 3, max: 50, message: 'Áî®Êà∑ÂêçÈïøÂ∫¶‰∏∫ 3-50 ‰∏™Â≠óÁ¨¶', trigger: ['input', 'blur'] }
  ],
  password: [
    { required: true, message: 'ËØ∑ËæìÂÖ•ÂØÜÁ†Å', trigger: ['input', 'blur'] },
    { min: 6, message: 'ÂØÜÁ†ÅÈïøÂ∫¶‰∏çËÉΩÂ∞ë‰∫é 6 ‰∏™Â≠óÁ¨¶', trigger: ['input', 'blur'] }
  ]
}

const handleLogin = async () => {
  if (!loginFormRef.value) return
  
  try {
    await loginFormRef.value.validate()
    loginLoading.value = true
    
    const result = await authStore.login(loginForm)
    
    if (result.success) {
      message.success(`Ê¨¢ËøéÂõûÊù•Ôºå${result.user?.name}ÔºÅ`)
      
      // Ë∑≥ËΩ¨Âà∞ÁõÆÊ†áÈ°µÈù¢ÊàñÈ¶ñÈ°µ
      const redirect = route.query.redirect as string || '/customers'
      router.push(redirect)
    } else {
      message.error(result.message || 'ÁôªÂΩïÂ§±Ë¥•')
    }
  } catch (error) {
    // Ë°®ÂçïÈ™åËØÅÂ§±Ë¥•
  } finally {
    loginLoading.value = false
  }
}

// È°µÈù¢Âä†ËΩΩÊó∂Ê£ÄÊü•ÊòØÂê¶Â∑≤ÁôªÂΩï
onMounted(() => {
  if (authStore.isAuthenticated) {
    router.push('/customers')
  }
})
</script>

<style scoped>
.login-container {
  min-height: 100vh;
  display: flex;
  align-items: center;
  justify-content: center;
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  padding: 20px;
}

.login-card {
  width: 100%;
  max-width: 400px;
  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
  border-radius: 16px;
  overflow: hidden;
  backdrop-filter: blur(8px);
}

.login-card :deep(.n-card) {
  background: rgba(255, 255, 255, 0.95);
}

.login-card :deep(.n-card-header) {
  text-align: center;
  font-weight: 600;
  font-size: 20px;
  color: #333;
}

@media (max-width: 480px) {
  .login-container {
    padding: 16px;
  }
  
  .login-card {
    max-width: none;
  }
}
</style>
```

### 4. Ë∑ØÁî±ÂÆàÂç´
```typescript
// router/index.ts
import { createRouter, createWebHistory } from 'vue-router'
import { useAuthStore } from '@/stores/auth'
import Login from '@/views/Login.vue'
import CustomerList from '@/views/CustomerList.vue'
import CustomerDetail from '@/views/CustomerDetail.vue'

const routes = [
  {
    path: '/login',
    name: 'Login',
    component: Login,
    meta: { requiresAuth: false }
  },
  {
    path: '/',
    redirect: '/customers'
  },
  {
    path: '/customers',
    name: 'CustomerList',
    component: CustomerList,
    meta: { requiresAuth: true }
  },
  {
    path: '/customers/:id',
    name: 'CustomerDetail',
    component: CustomerDetail,
    meta: { requiresAuth: true }
  }
]

const router = createRouter({
  history: createWebHistory(),
  routes
})

// Ë∑ØÁî±ÂÆàÂç´
router.beforeEach(async (to, from, next) => {
  const authStore = useAuthStore()
  
  // Â¶ÇÊûúË∑ØÁî±ÈúÄË¶ÅËÆ§ËØÅ
  if (to.meta.requiresAuth) {
    // Ê£ÄÊü•ÊòØÂê¶Â∑≤ËÆ§ËØÅ
    if (!authStore.isAuthenticated) {
      // Â∞ùËØï‰ªéÊú¨Âú∞Â≠òÂÇ®ÊÅ¢Â§çËÆ§ËØÅÁä∂ÊÄÅ
      const restored = await authStore.initAuth()
      
      if (!restored) {
        // Ë∑≥ËΩ¨Âà∞ÁôªÂΩïÈ°µÔºåÂπ∂‰øùÂ≠òÁõÆÊ†áË∑ØÁî±
        next({
          path: '/login',
          query: { redirect: to.fullPath }
        })
        return
      }
    }
  }
  
  // Â¶ÇÊûúÂ∑≤ÁôªÂΩïÁî®Êà∑ËÆøÈóÆÁôªÂΩïÈ°µÔºåË∑≥ËΩ¨Âà∞ÂÆ¢Êà∑ÂàóË°®
  if (to.path === '/login' && authStore.isAuthenticated) {
    next('/customers')
    return
  }
  
  next()
})

export default router
```

### 5. HTTPËØ∑Ê±ÇÊã¶Êà™Âô®
```typescript
// utils/request.ts
import axios, { type AxiosResponse, type AxiosError } from 'axios'
import { useAuthStore } from '@/stores/auth'
import { useMessage } from 'naive-ui'
import router from '@/router'

const request = axios.create({
  baseURL: import.meta.env.VITE_API_BASE_URL || 'http://localhost:3000',
  timeout: 10000
})

// ËØ∑Ê±ÇÊã¶Êà™Âô® - Ê∑ªÂä†ËÆ§ËØÅÂ§¥
request.interceptors.request.use(
  (config) => {
    const authStore = useAuthStore()
    
    if (authStore.token) {
      config.headers.Authorization = `Bearer ${authStore.token}`
    }
    
    return config
  },
  (error) => {
    return Promise.reject(error)
  }
)

// ÂìçÂ∫îÊã¶Êà™Âô® - Â§ÑÁêÜËÆ§ËØÅÈîôËØØ
request.interceptors.response.use(
  (response: AxiosResponse) => {
    return response
  },
  async (error: AxiosError) => {
    const authStore = useAuthStore()
    const message = useMessage()
    
    if (error.response) {
      const status = error.response.status
      
      switch (status) {
        case 401:
          // TokenËøáÊúüÊàñÊó†Êïà
          message.error('ÁôªÂΩïÂ∑≤ËøáÊúüÔºåËØ∑ÈáçÊñ∞ÁôªÂΩï')
          await authStore.logout()
          router.push('/login')
          break
          
        case 403:
          message.error('Ê≤°ÊúâÊùÉÈôêÊâßË°åÊ≠§Êìç‰Ωú')
          break
          
        case 404:
          message.error('ËØ∑Ê±ÇÁöÑËµÑÊ∫ê‰∏çÂ≠òÂú®')
          break
          
        case 500:
          message.error('ÊúçÂä°Âô®ÂÜÖÈÉ®ÈîôËØØ')
          break
          
        default:
          message.error(error.response.data?.message || 'ËØ∑Ê±ÇÂ§±Ë¥•')
      }
    } else if (error.request) {
      message.error('ÁΩëÁªúËøûÊé•ÈîôËØØ')
    } else {
      message.error('ËØ∑Ê±ÇÈÖçÁΩÆÈîôËØØ')
    }
    
    return Promise.reject(error)
  }
)

export default request
```

### 6. Êõ¥Êñ∞ÂêéÁöÑÂÆ¢Êà∑ÂàóË°®È°µÈù¢
```vue
<!-- views/CustomerList.vue -->
<template>
  <div class="customer-list-container">
    <!-- È°µÈù¢Â§¥ÈÉ® -->
    <n-page-header @back="null">
      <template #title>
        ÂÆ¢Êà∑ÁÆ°ÁêÜ
      </template>
      <template #extra>
        <n-space>
          <n-text depth="3">
            Ê¨¢ËøéÔºå{{ authStore.user?.name }}
          </n-text>
          <n-dropdown :options="userMenuOptions" @select="handleUserMenuSelect">
            <n-button quaternary circle>
              <n-icon :component="PersonOutline" size="20" />
            </n-button>
          </n-dropdown>
        </n-space>
      </template>
    </n-page-header>

    <!-- ÊêúÁ¥¢ÂíåËøáÊª§ -->
    <n-space class="search-bar" justify="space-between">
      <n-input 
        v-model:value="searchQuery"
        placeholder="ÊêúÁ¥¢ÂÆ¢Êà∑ÂßìÂêçÊàñÁîµËØù"
        clearable
        @input="handleSearch"
        style="max-width: 300px"
      >
        <template #prefix>
          <n-icon :component="SearchOutlined" />
        </template>
      </n-input>
      
      <n-button type="primary" @click="showCreateModal = true">
        <template #icon>
          <n-icon :component="PlusOutlined" />
        </template>
        Ê∑ªÂä†ÂÆ¢Êà∑
      </n-button>
    </n-space>

    <!-- ÂÆ¢Êà∑ÂàóË°® -->
    <n-spin :show="loading">
      <n-list bordered v-if="customers.length > 0">
        <n-list-item v-for="customer in customers" :key="customer.id">
          <CustomerCard 
            :customer="customer" 
            @click="goToDetail(customer.id)"
            @edit="handleEditCustomer"
            @delete="handleDeleteCustomer"
          />
        </n-list-item>
      </n-list>
      
      <n-empty 
        v-else-if="!loading" 
        description="ÊöÇÊó†ÂÆ¢Êà∑Êï∞ÊçÆ"
        size="large"
        style="margin: 40px 0"
      >
        <template #extra>
          <n-button size="small" @click="showCreateModal = true">
            ÂàõÂª∫Á¨¨‰∏Ä‰∏™ÂÆ¢Êà∑
          </n-button>
        </template>
      </n-empty>
    </n-spin>

    <!-- ÂàÜÈ°µ -->
    <n-pagination
      v-if="customers.length > 0"
      v-model:page="currentPage"
      :page-count="totalPages"
      show-size-picker
      :page-sizes="[10, 20, 50]"
      :page-slot="7"
      @update:page="handlePageChange"
      @update:page-size="handlePageSizeChange"
    />

    <!-- ÂàõÂª∫/ÁºñËæëÂÆ¢Êà∑ÂºπÁ™ó -->
    <CustomerFormModal 
      v-model:show="showCreateModal"
      :customer="editingCustomer"
      @success="handleCustomerSaved"
    />
  </div>
</template>

<script setup lang="ts">
import { ref, reactive, onMounted, computed } from 'vue'
import { useRouter } from 'vue-router'
import { useMessage } from 'naive-ui'
import { 
  SearchOutlined, 
  PlusOutlined, 
  PersonOutline,
  LogOutOutline,
  SettingsOutline 
} from '@vicons/ionicons5'
import { useAuthStore } from '@/stores/auth'
import { customerApi } from '@/services/customer'
import type { CustomerWithLatestTrack } from '@/types/customer'
import CustomerCard from '@/components/CustomerCard.vue'
import CustomerFormModal from '@/components/CustomerFormModal.vue'

const router = useRouter()
const message = useMessage()
const authStore = useAuthStore()

// Áä∂ÊÄÅÁÆ°ÁêÜ
const loading = ref(false)
const customers = ref<CustomerWithLatestTrack[]>([])
const searchQuery = ref('')
const currentPage = ref(1)
const pageSize = ref(20)
const totalCount = ref(0)
const showCreateModal = ref(false)
const editingCustomer = ref<CustomerWithLatestTrack | null>(null)

// ËÆ°ÁÆóÂ±ûÊÄß
const totalPages = computed(() => Math.ceil(totalCount.value / pageSize.value))

// Áî®Êà∑ËèúÂçïÈÄâÈ°π
const userMenuOptions = [
  {
    label: '‰∏™‰∫∫ËÆæÁΩÆ',
    key: 'settings',
    icon: () => h(SettingsOutline)
  },
  {
    type: 'divider'
  },
  {
    label: 'ÈÄÄÂá∫ÁôªÂΩï',
    key: 'logout',
    icon: () => h(LogOutOutline)
  }
]

// Â§ÑÁêÜÁî®Êà∑ËèúÂçïÈÄâÊã©
const handleUserMenuSelect = (key: string) => {
  switch (key) {
    case 'settings':
      // TODO: ÊâìÂºÄËÆæÁΩÆÈ°µÈù¢
      message.info('‰∏™‰∫∫ËÆæÁΩÆÂäüËÉΩÂºÄÂèë‰∏≠')
      break
    case 'logout':
      handleLogout()
      break
  }
}

// ÈÄÄÂá∫ÁôªÂΩï
const handleLogout = async () => {
  await authStore.logout()
  message.success('Â∑≤ÊàêÂäüÈÄÄÂá∫ÁôªÂΩï')
  router.push('/login')
}

// Âä†ËΩΩÂÆ¢Êà∑ÂàóË°®
const loadCustomers = async () => {
  try {
    loading.value = true
    const response = await customerApi.getCustomers({
      page: currentPage.value,
      limit: pageSize.value,
      search: searchQuery.value
    })
    
    customers.value = response.data.customers
    totalCount.value = response.data.total
  } catch (error) {
    message.error('Âä†ËΩΩÂÆ¢Êà∑ÂàóË°®Â§±Ë¥•')
  } finally {
    loading.value = false
  }
}

// ÂÖ∂‰ªñ‰∫ã‰ª∂Â§ÑÁêÜÂáΩÊï∞...
const goToDetail = (customerId: number) => {
  router.push(`/customers/${customerId}`)
}

const handleEditCustomer = (customer: CustomerWithLatestTrack) => {
  editingCustomer.value = customer
  showCreateModal.value = true
}

const handleDeleteCustomer = async (customer: CustomerWithLatestTrack) => {
  // TODO: ÂÆûÁé∞Âà†Èô§Á°ÆËÆ§ÂØπËØùÊ°Ü
  try {
    await customerApi.deleteCustomer(customer.id)
    message.success('ÂÆ¢Êà∑Âà†Èô§ÊàêÂäü')
    loadCustomers()
  } catch (error) {
    message.error('Âà†Èô§ÂÆ¢Êà∑Â§±Ë¥•')
  }
}

const handleCustomerSaved = () => {
  showCreateModal.value = false
  editingCustomer.value = null
  loadCustomers()
}

const handleSearch = () => {
  currentPage.value = 1
  loadCustomers()
}

const handlePageChange = (page: number) => {
  currentPage.value = page
  loadCustomers()
}

const handlePageSizeChange = (size: number) => {
  pageSize.value = size
  currentPage.value = 1
  loadCustomers()
}

// È°µÈù¢Âä†ËΩΩ
onMounted(() => {
  loadCustomers()
})
</script>

<style scoped>
.customer-list-container {
  padding: 16px;
  max-width: 1200px;
  margin: 0 auto;
}

.search-bar {
  margin: 24px 0;
  flex-direction: column;
}

@media (min-width: 768px) {
  .search-bar {
    flex-direction: row;
  }
}

.n-pagination {
  margin-top: 24px;
  justify-content: center;
}
</style>
```

---

## üìÅ È°πÁõÆÁªìÊûÑ

```
customer-tracker/
‚îú‚îÄ‚îÄ backend/
‚îÇ   ‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ main.rs
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ lib.rs
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ cli.rs              # ÂëΩ‰ª§Ë°åÂ∑•ÂÖ∑
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ config.rs           # ÈÖçÁΩÆÁÆ°ÁêÜ
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ database.rs         # Êï∞ÊçÆÂ∫ìËøûÊé•
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ entities/           # Sea-ORMÂÆû‰Ωì
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ mod.rs
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ user.rs
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ customer.rs
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ customer_track.rs
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ next_action.rs  # Êûö‰∏æÂÆö‰πâ
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ handlers/           # HTTPÂ§ÑÁêÜÂô®
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ mod.rs
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ auth.rs         # ËÆ§ËØÅÁõ∏ÂÖ≥
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ customer.rs
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ customer_track.rs
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ services/           # ‰∏öÂä°ÈÄªËæëÂ±Ç
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ mod.rs
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ auth_service.rs
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ customer_service.rs
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ track_service.rs
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ middleware/         # ‰∏≠Èó¥‰ª∂
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ mod.rs
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ auth.rs         # JWTËÆ§ËØÅ‰∏≠Èó¥‰ª∂
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ utils/              # Â∑•ÂÖ∑ÂáΩÊï∞
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ mod.rs
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ password.rs
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ jwt.rs          # JWTÂ∑•ÂÖ∑
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ validation.rs   # Êï∞ÊçÆÈ™åËØÅ
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ routes.rs           # Ë∑ØÁî±ÂÆö‰πâ
‚îÇ   ‚îú‚îÄ‚îÄ migrations/             # Êï∞ÊçÆÂ∫ìËøÅÁßª
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ 001_create_users.sql
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ 002_create_customers.sql
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ 003_create_customer_tracks.sql
‚îÇ   ‚îú‚îÄ‚îÄ Cargo.toml
‚îÇ   ‚îî‚îÄ‚îÄ .env
‚îú‚îÄ‚îÄ frontend/
‚îÇ   ‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ main.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ App.vue
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ router/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ index.ts        # Ë∑ØÁî±ÈÖçÁΩÆÂíåÂÆàÂç´
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ stores/             # PiniaÁä∂ÊÄÅÁÆ°ÁêÜ
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ auth.ts         # ËÆ§ËØÅÁä∂ÊÄÅ
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ customer.ts
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ track.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ views/              # È°µÈù¢ÁªÑ‰ª∂
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Login.vue       # ÁôªÂΩïÈ°µÈù¢
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ CustomerList.vue # ÂÆ¢Êà∑ÂàóË°®
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ CustomerDetail.vue
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ components/         # ÂÖ¨ÂÖ±ÁªÑ‰ª∂
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ CustomerCard.vue
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ CustomerFormModal.vue
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ TrackTimeline.vue
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ NextActionSelect.vue
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ProtectedRoute.vue # Ë∑ØÁî±‰øùÊä§ÁªÑ‰ª∂
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ services/           # APIÊúçÂä°
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ api.ts
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ auth.ts         # ËÆ§ËØÅAPI
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ customer.ts
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ track.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ types/              # TypeScriptÁ±ªÂûãÂÆö‰πâ
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ auth.ts         # ËÆ§ËØÅÁõ∏ÂÖ≥Á±ªÂûã
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ customer.ts
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ track.ts
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ utils/              # Â∑•ÂÖ∑ÂáΩÊï∞
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ format.ts
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ request.ts      # HTTPËØ∑Ê±ÇÊã¶Êà™Âô®
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ storage.ts      # Êú¨Âú∞Â≠òÂÇ®Â∑•ÂÖ∑
‚îÇ   ‚îú‚îÄ‚îÄ package.json
‚îÇ   ‚îú‚îÄ‚îÄ vite.config.ts
‚îÇ   ‚îú‚îÄ‚îÄ tsconfig.json
‚îÇ   ‚îî‚îÄ‚îÄ .env.development
‚îú‚îÄ‚îÄ README.md
‚îú‚îÄ‚îÄ docker-compose.yml          # ÈÉ®ÁΩ≤ÈÖçÁΩÆ
‚îî‚îÄ‚îÄ .github/workflows/          # CI/CDÈÖçÁΩÆ
    ‚îî‚îÄ‚îÄ deploy.yml
```

---

## üõ†Ô∏è ÂºÄÂèëËÆ°Âàí

### Á¨¨‰∏ÄÈò∂ÊÆµÔºöËÆ§ËØÅÁ≥ªÁªüÊê≠Âª∫ (1.5Âë®)
- [ ] È°πÁõÆÂàùÂßãÂåñÂíå‰æùËµñÂÆâË£Ö
- [ ] Êï∞ÊçÆÂ∫ìÊ®°ÂûãËÆæËÆ°ÂíåËøÅÁßª
- [ ] JWTËÆ§ËØÅ‰∏≠Èó¥‰ª∂ÂÆûÁé∞
- [ ] Áî®Êà∑ÁôªÂΩï/ÁôªÂá∫API
- [ ] ÂâçÁ´ØÁôªÂΩïÈ°µÈù¢ÂíåË∑ØÁî±ÂÆàÂç´
- [ ] CLIÁî®Êà∑ÁÆ°ÁêÜÂ∑•ÂÖ∑

### Á¨¨‰∫åÈò∂ÊÆµÔºöÊ†∏ÂøÉÂäüËÉΩÂºÄÂèë (2Âë®)
- [ ] ÂÆ¢Êà∑‰ø°ÊÅØCRUD APIÔºàÂ∏¶ÊùÉÈôêÊéßÂà∂Ôºâ
- [ ] ÂÆ¢Êà∑ËøΩË∏™ËÆ∞ÂΩïAPIÔºàÂ∏¶ÊùÉÈôêÊéßÂà∂Ôºâ
- [ ] NextActionÊûö‰∏æÁ±ªÂûãÂÆûÁé∞
- [ ] ÂâçÁ´ØËÆ§ËØÅÁä∂ÊÄÅÁÆ°ÁêÜ
- [ ] ÂÆ¢Êà∑ÂàóË°®È°µÈù¢ÔºàÊòæÁ§∫ÂΩìÂâçÁî®Êà∑ÁöÑÂÆ¢Êà∑Ôºâ

### Á¨¨‰∏âÈò∂ÊÆµÔºöÁïåÈù¢ÂÆåÂñÑÂíå‰ºòÂåñ (1.5Âë®)
- [ ] ÂÆ¢Êà∑ËØ¶ÊÉÖÈ°µÈù¢ÂíåÊó∂Èó¥Á∫ø
- [ ] NextActionÁä∂ÊÄÅÊòæÁ§∫‰ºòÂåñ
- [ ] ÁßªÂä®Á´ØÂìçÂ∫îÂºè‰ºòÂåñ
- [ ] Áî®Êà∑‰ΩìÈ™å‰ºòÂåñ
- [ ] ÈîôËØØÂ§ÑÁêÜÂíåÂä†ËΩΩÁä∂ÊÄÅ

### Á¨¨ÂõõÈò∂ÊÆµÔºöÊµãËØïÂíåÈÉ®ÁΩ≤ (1Âë®)
- [ ] ÂçïÂÖÉÊµãËØïÂíåÈõÜÊàêÊµãËØï
- [ ] ÊùÉÈôêÊéßÂà∂ËæπÁïåÊµãËØï
- [ ] ÊÄßËÉΩ‰ºòÂåñ
- [ ] ÂÆâÂÖ®ÊÄßÊµãËØï
- [ ] DockerÈÉ®ÁΩ≤ÈÖçÁΩÆ
- [ ] ÊñáÊ°£ÂÆåÂñÑ

---

## üîß ÂºÄÂèëÁéØÂ¢ÉÈÖçÁΩÆ

### ÂêéÁ´ØÂºÄÂèëÁéØÂ¢É
```toml
# Cargo.toml
[dependencies]
axum = "0.8"
axum-extra = { version = "0.9", features = ["typed-header"] }
sea-orm = { version = "1.0", features = ["sqlx-sqlite", "runtime-tokio-rustls", "macros"] }
sqlx = { version = "0.8", features = ["runtime-tokio-rustls", "sqlite", "chrono"] }
tokio = { version = "1.0", features = ["full"] }
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
chrono = { version = "0.4", features = ["serde"] }
clap = { version = "4.0", features = ["derive"] }
jsonwebtoken = "9.0"
bcrypt = "0.15"
tracing = "0.1"
tracing-subscriber = "0.3"
dotenv = "0.15"
anyhow = "1.0"
thiserror = "1.0"
tower = "0.4"
tower-http = { version = "0.5", features = ["cors", "fs"] }
uuid = { version = "1.0", features = ["v4", "serde"] }
```

### ÂâçÁ´ØÂºÄÂèëÁéØÂ¢É
```json
{
  "dependencies": {
    "vue": "^3.4.0",
    "vue-router": "^4.2.0",
    "pinia": "^2.1.0",
    "naive-ui": "^2.35.0",
    "@vicons/ionicons5": "^0.12.0",
    "axios": "^1.6.0"
  },
  "devDependencies": {
    "@vitejs/plugin-vue": "^4.5.0",
    "vite": "^5.0.0",
    "typescript": "^5.2.0",
    "@types/node": "^20.8.0",
    "unplugin-auto-import": "^0.17.0",
    "unplugin-vue-components": "^0.26.0"
  }
}
```

### ÁéØÂ¢ÉÂèòÈáèÈÖçÁΩÆ
```bash
# backend/.env
DATABASE_URL=sqlite://./customer_tracker.db
JWT_SECRET=your-super-secret-jwt-key-here-change-in-production-min-256-bits
JWT_EXPIRE_HOURS=24
LOG_LEVEL=debug
SERVER_HOST=0.0.0.0
SERVER_PORT=3000

# ÈªòËÆ§ÁÆ°ÁêÜÂëòË¥¶Êà∑Ôºà‰ªÖÂºÄÂèëÁéØÂ¢ÉÔºâ
ADMIN_USERNAME=admin
ADMIN_PASSWORD=admin123
ADMIN_NAME=Á≥ªÁªüÁÆ°ÁêÜÂëò

# CORSÈÖçÁΩÆ
CORS_ORIGIN=http://localhost:5173
```

```bash
# frontend/.env.development
VITE_API_BASE_URL=http://localhost:3000
VITE_APP_TITLE=ÂÆ¢Êà∑ËøΩË∏™Á≥ªÁªü
VITE_TOKEN_STORAGE_KEY=customer_tracker_token
```

### CLIÂëΩ‰ª§Á§∫‰æã
```rust
// src/cli.rs
use clap::{Args, Parser, Subcommand};
use crate::entities::next_action::NextAction;

#[derive(Parser)]
#[command(name = "customer-tracker")]
#[command(about = "ÂÆ¢Êà∑ËøΩË∏™Á≥ªÁªüÁÆ°ÁêÜÂ∑•ÂÖ∑")]
pub struct Cli {
    #[command(subcommand)]
    pub command: Commands,
}

#[derive(Subcommand)]
pub enum Commands {
    /// Áî®Êà∑ÁÆ°ÁêÜ
    User(UserArgs),
    /// Êï∞ÊçÆÂ∫ìÁÆ°ÁêÜ
    Database(DatabaseArgs),
    /// ÊúçÂä°Âô®ÁÆ°ÁêÜ
    Server(ServerArgs),
}

#[derive(Args)]
pub struct UserArgs {
    #[command(subcommand)]
    pub action: UserAction,
}

#[derive(Subcommand)]
pub enum UserAction {
    /// ÂàõÂª∫Êñ∞Áî®Êà∑
    Create {
        #[arg(short, long)]
        username: String,
        #[arg(short, long)]
        password: String,
        #[arg(short, long)]
        name: String,
    },
    /// ÂàóÂá∫ÊâÄÊúâÁî®Êà∑
    List {
        #[arg(short, long, default_value = "10")]
        limit: u32,
    },
    /// ÈáçÁΩÆÁî®Êà∑ÂØÜÁ†Å
    ResetPassword {
        #[arg(short, long)]
        username: String,
        #[arg(short, long)]
        password: String,
    },
    /// Á¶ÅÁî®/ÂêØÁî®Áî®Êà∑
    Toggle {
        #[arg(short, long)]
        username: String,
    },
}

#[derive(Args)]
pub struct DatabaseArgs {
    #[command(subcommand)]
    pub action: DatabaseAction,
}

#[derive(Subcommand)]
pub enum DatabaseAction {
    /// ËøêË°åÊï∞ÊçÆÂ∫ìËøÅÁßª
    Migrate,
    /// ÂàõÂª∫ËøÅÁßªÊñá‰ª∂
    CreateMigration {
        #[arg(short, long)]
        name: String,
    },
    /// Êï∞ÊçÆÂ∫ìÁä∂ÊÄÅ
    Status,
}

#[derive(Args)]
pub struct ServerArgs {
    #[command(subcommand)]
    pub action: ServerAction,
}

#[derive(Subcommand)]
pub enum ServerAction {
    /// ÂêØÂä®ÊúçÂä°Âô®
    Start {
        #[arg(short, long, default_value = "3000")]
        port: u16,
        #[arg(long, default_value = "127.0.0.1")]
        host: String,
    },
    /// ÁîüÊàêJWTÂØÜÈí•
    GenerateJwtSecret,
}

// ‰ΩøÁî®Á§∫‰æãÔºö
// cargo run -- user create -u admin -p password123 -n "Á≥ªÁªüÁÆ°ÁêÜÂëò"
// cargo run -- user list --limit 20
// cargo run -- database migrate
// cargo run -- server start --port 8080
// cargo run -- server generate-jwt-secret
```

### ÂºÄÂèëÂêØÂä®ËÑöÊú¨
```bash
# scripts/dev.sh
#!/bin/bash

echo "ÂêØÂä®ÂÆ¢Êà∑ËøΩË∏™Á≥ªÁªüÂºÄÂèëÁéØÂ¢É..."

# Ê£ÄÊü•ÊòØÂê¶ÂÆâË£Ö‰∫ÜÂøÖË¶ÅÁöÑÂ∑•ÂÖ∑
command -v cargo >/dev/null 2>&1 || { echo "ËØ∑ÂÖàÂÆâË£Ö Rust"; exit 1; }
command -v npm >/dev/null 2>&1 || { echo "ËØ∑ÂÖàÂÆâË£Ö Node.js"; exit 1; }

# ÂêØÂä®ÂêéÁ´Ø
echo "ÂêØÂä®ÂêéÁ´ØÊúçÂä°..."
cd backend
if [ ! -f ".env" ]; then
    echo "ÂàõÂª∫ÂêéÁ´ØÁéØÂ¢ÉÂèòÈáèÊñá‰ª∂..."
    cp .env.example .env
fi
cargo run -- database migrate
cargo run -- user create -u admin -p admin123 -n "ÁÆ°ÁêÜÂëò" 2>/dev/null || true
cargo run -- server start &
BACKEND_PID=$!

# Á≠âÂæÖÂêéÁ´ØÂêØÂä®
sleep 3

# ÂêØÂä®ÂâçÁ´Ø
echo "ÂêØÂä®ÂâçÁ´ØÊúçÂä°..."
cd ../frontend
if [ ! -f ".env.development" ]; then
    echo "ÂàõÂª∫ÂâçÁ´ØÁéØÂ¢ÉÂèòÈáèÊñá‰ª∂..."
    cp .env.development.example .env.development
fi
npm install
npm run dev &
FRONTEND_PID=$!

echo "ÂºÄÂèëÁéØÂ¢ÉÂ∑≤ÂêØÂä®Ôºö"
echo "- ÂêéÁ´ØÊúçÂä°: http://localhost:3000"
echo "
